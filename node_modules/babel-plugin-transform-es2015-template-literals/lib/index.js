"use strict";

exports.__esModule = true;

exports.default = function (_ref) {
  var t = _ref.types;

  function buildConcatCallExressions(items) {
    var avail = true;
    return items.reduce(function (left, right) {
      var canBeInserted = t.isLiteral(right);

      if (!canBeInserted && avail) {
        canBeInserted = true;
        avail = false;
      }
      if (canBeInserted && t.isCallExpression(left)) {
        left.arguments.push(right);
        return left;
      }
      return t.callExpression(t.memberExpression(left, t.identifier("concat")), [right]);
    });
  }

  return {
    visitor: {
      TaggedTemplateExpression: function TaggedTemplateExpression(path, state) {
        var node = path.node;
        var quasi = node.quasi;


        var strings = [];
        var raws = [];

        for (var _iterator = quasi.quasis, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
          var _ref2;

          if (_isArray) {
            if (_i >= _iterator.length) break;
            _ref2 = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done) break;
            _ref2 = _i.value;
          }

          var elem = _ref2;
          var _elem$value = elem.value,
              raw = _elem$value.raw,
              cooked = _elem$value.cooked;

          var value = cooked == null ? path.scope.buildUndefinedNode() : t.stringLiteral(cooked);

          strings.push(value);
          raws.push(t.stringLiteral(raw));
        }

        var templateName = "taggedTemplateLiteral";
        if (state.opts.loose) templateName += "Loose";

        var templateObject = state.file.addTemplateObject(templateName, t.arrayExpression(strings), t.arrayExpression(raws));

        var args = [templateObject].concat(quasi.expressions);

        path.replaceWith(t.callExpression(node.tag, args));
      },
      TemplateLiteral: function TemplateLiteral(path, state) {
        var nodes = [];
        var expressions = path.get("expressions");

        var index = 0;
        for (var _iterator2 = path.node.quasis, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
          var _ref3;

          if (_isArray2) {
            if (_i2 >= _iterator2.length) break;
            _ref3 = _iterator2[_i2++];
          } else {
            _i2 = _iterator2.next();
            if (_i2.done) break;
            _ref3 = _i2.value;
          }

          var elem = _ref3;

          if (elem.value.cooked) {
            nodes.push(t.stringLiteral(elem.value.cooked));
          }

          if (index < expressions.length) {
            var expr = expressions[index++];
            var node = expr.node;
            if (!t.isStringLiteral(node, { value: "" })) {
              nodes.push(node);
            }
          }
        }

        var considerSecondNode = state.opts.spec || !t.isStringLiteral(nodes[1]);
        if (!t.isStringLiteral(nodes[0]) && considerSecondNode) {
          nodes.unshift(t.stringLiteral(""));
        }
        var root = nodes[0];

        if (state.opts.spec) {
          if (nodes.length > 1) {
            root = buildConcatCallExressions(nodes);
          }
        } else {
          for (var i = 1; i < nodes.length; i++) {
            root = t.binaryExpression("+", root, nodes[i]);
          }
        }

        path.replaceWith(root);
      }
    }
  };
};