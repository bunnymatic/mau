import MagicString from 'magic-string';
import { Node } from 'babel-types';
import { Scope } from 'babel-traverse';
import { Token } from '../types';
/**
 * The state of one proposed binding. As new usages are seen, the
 * mostSpecificScope field is updated accordingly.
 */
export declare class BindingState {
    name: string;
    mostSpecificScope: Scope;
    isInOriginalPosition: boolean;
    constructor(name: string, scope: Scope);
    handleSeenScope(scope: Scope): void;
}
/**
 * Information about an "inline binding", a potential opportunity to insert
 * `var` directly at the variable declaration.
 */
export declare type InlineBindingState = {
    node: Node;
    bindings: Array<BindingState>;
    shouldRemoveParens: boolean;
};
/**
 * Mutable structure containing the current declarations in the traversal. Each
 * TraverseState object corresponds to one scope in the source code (which could
 * be any block, not just a function scope), so the full set of TraverseState
 * objects forms a tree structure, but any any point in time, the current
 * TraverseState forms a path through all parent scopes.
 *
 * Even though every scope gets a TraverseState, only function scopes can
 * actually "own" bindings. This makes it easy to detect when two variables are
 * the same.
 */
export default class TraverseState {
    scope: Scope;
    parentState: TraverseState | null;
    ownedBindings: Map<string, BindingState>;
    ownedInlineBindings: Array<InlineBindingState>;
    constructor(scope: Scope, parentState?: TraverseState | null);
    /**
     * Declare that there is an assignment to a variable with this name in this
     * scope.
     */
    addBinding(name: string): void;
    /**
     * Note that this identifier appears in this scope. This won't create
     * bindings, but might update the most specific scope for existing bindings.
     */
    handleSeenIdentifier(name: string): void;
    /**
     * Declare that, if possible, the given names should all have declarations
     * added by inserting `var` at the start of the specified node. If any of them
     * end up changing scopes due to later information, or if any of them are
     * already declared, we'll just add the names to the most specific scope.
     *
     * To make calling code simpler, this method allows an empty array of names
     * (in which case it's a no-op) and allows names that are already defined
     * (in which case we immediately know that we won't be able to do an inline
     * binding).
     */
    addInlineBinding(node: Node, names: Array<string>, {shouldRemoveParens}: {
        shouldRemoveParens: boolean;
    }): void;
    createBinding(name: string, scope: Scope): BindingState;
    getEnclosingBindingOwner(): TraverseState;
    canOwnBindings(): boolean;
    resolveName(name: string): BindingState | 'NOT_FOUND' | 'ALREADY_DECLARED';
    /**
     * When we finish processing a function, we know that we have all information
     * we need for variables scoped to this function, so we can insert the `var`
     * declarations at the right places.
     */
    commitDeclarations(editor: MagicString, source: string, tokens: Array<Token>): void;
    /**
     * Get all names that we still need to declare (ones not in usedNames), sorted
     * and grouped by scope.
     */
    getBindingNamesByScope(usedNames: Set<string>): Map<Scope, Array<string>>;
    getFirstStatementForScope(scope: Scope): Node | null;
}
