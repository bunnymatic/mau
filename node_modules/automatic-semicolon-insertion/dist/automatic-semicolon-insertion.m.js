function process(config) {
  var ast = config.ast;
  var traverse = config.traverse;
  var firstTokenOfNode = config.firstTokenOfNode;
  var lastTokenOfNode = config.lastTokenOfNode;
  var tokenAfterToken = config.tokenAfterToken;
  var sourceOfToken = config.sourceOfToken;
  var insert = config.insert;
  var remove = config.remove;
  var startOfToken = config.startOfToken;
  var endOfToken = config.endOfToken;
  var startOfNode = config.startOfNode;
  var endOfNode = config.endOfNode;


  traverse(ast, function (node, parent) {
    switch (node.type) {
      case 'VariableDeclaration':
        var isForInit = parent && parent.type === 'ForStatement' && parent.init === node || /^For(?:In|Of)Statement/.test(parent.type) && parent.left === node;

        if (!isForInit) {
          checkForSemicolon(node);
        }
        break;

      case 'ExpressionStatement':
      case 'ReturnStatement':
      case 'ThrowStatement':
      case 'DoWhileStatement':
      case 'DebuggerStatement':
      case 'BreakStatement':
      case 'ContinueStatement':
      case 'ImportDeclaration':
      case 'ExportAllDeclaration':
        checkForSemicolon(node);
        break;

      case 'ExportNamedDeclaration':
        if (!node.declaration) {
          checkForSemicolon(node);
        }
        break;

      case 'ExportDefaultDeclaration':
        if (/(?:Class|Function)Declaration/.test(node.declaration.type)) {
          if (!node.declaration.id) {
            checkForSemicolon(node);
          }
        } else {
          checkForSemicolon(node);
        }
        break;

      case 'EmptyStatement':
        switch (parent.type) {
          case 'ForStatement':
          case 'ForOfStatement':
          case 'ForInStatement':
          case 'WhileStatement':
          case 'DoWhileStatement':
            // These are allowed to have empty statement bodies, for example.
            break;

          default:
            remove(startOfNode(node), endOfNode(node));
            break;
        }
        break;

      case 'ClassBody':
        checkClassBodyForSemicolon(tokenAfterToken(firstTokenOfNode(node)));
        break;

      case 'ClassMethod':
      case 'MethodDefinition':
        checkClassBodyForSemicolon(tokenAfterToken(lastTokenOfNode(node)));
        break;
    }
  });

  /**
   * Checks a node to see if it's followed by a semicolon.
   */
  function checkForSemicolon(node) {
    var lastToken = lastTokenOfNode(node);

    if (sourceOfToken(lastToken) !== ';') {
      insert(endOfToken(lastToken), ';');
    }
  }

  /**
   * Class bodies don't need semicolons.
   */
  function checkClassBodyForSemicolon(token) {
    while (token) {
      var source = sourceOfToken(token);

      if (source === ';') {
        remove(startOfToken(token), endOfToken(token));
      } else {
        break;
      }

      token = tokenAfterToken(token);
    }
  }
}

export default process;