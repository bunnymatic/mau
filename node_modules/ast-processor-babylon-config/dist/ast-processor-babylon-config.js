(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('babel-traverse')) :
  typeof define === 'function' && define.amd ? define(['babel-traverse'], factory) :
  (global.ASI = factory(global._traverse));
}(this, function (_traverse) { 'use strict';

  _traverse = 'default' in _traverse ? _traverse['default'] : _traverse;

  function build(source, ast) {
    var insertions = [];
    var removals = [];
    var tokens = ast.tokens;

    return {
      ast: ast,
      insertions: insertions,
      removals: removals,

      traverse: function traverse(node, iterator) {
        _traverse(node, {
          enter: function enter(path) {
            iterator(path.node, path.parent);
          }
        });
      },
      firstTokenOfNode: function firstTokenOfNode(node) {
        for (var i = 0; i < tokens.length; i++) {
          var _token = tokens[i];
          if (_token.start === node.start) {
            return _token;
          }
        }
        throw new Error('cannot find first token for node ' + node.type + ' at ' + (node.loc.start.line + ':' + (node.loc.start.column + 1)));
      },
      lastTokenOfNode: function lastTokenOfNode(node) {
        for (var i = 0; i < tokens.length; i++) {
          var _token2 = tokens[i];
          if (_token2.end === node.end) {
            return _token2;
          }
        }
        throw new Error('cannot find last token for node ' + node.type + ' at ' + (node.loc.start.line + ':' + (node.loc.start.column + 1)));
      },
      tokenAfterToken: function tokenAfterToken(token) {
        var index = tokens.indexOf(token);
        if (index < 0) {
          throw new Error('cannot find token in tokens: ' + JSON.stringify(token));
        }
        return tokens[index + 1];
      },
      sourceOfToken: function sourceOfToken(token) {
        return source.slice(token.start, token.end);
      },
      insert: function insert(index, content) {
        insertions.push({ index: index, content: content });
      },
      remove: function remove(start, end) {
        removals.push({ start: start, end: end });
      },
      startOfNode: function startOfNode(node) {
        return node.start;
      },
      endOfNode: function endOfNode(node) {
        return node.end;
      },
      startOfToken: function startOfToken(token) {
        return token.start;
      },
      endOfToken: function endOfToken(token) {
        return token.end;
      }
    };
  }

  return build;

}));