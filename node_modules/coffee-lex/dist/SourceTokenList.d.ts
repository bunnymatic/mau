import SourceToken from './SourceToken';
import SourceTokenListIndex from './SourceTokenListIndex';
import SourceType from './SourceType';
export declare type SourceTokenListIndexRange = [SourceTokenListIndex, SourceTokenListIndex];
/**
 * Represents a list of tokens and provides various utility functions for
 * finding tokens within it.
 */
export default class SourceTokenList {
    private _tokens;
    private _indexCache;
    private _indexBySourceIndex;
    private _indexByStartSourceIndex;
    private _indexByEndSourceIndex;
    readonly length: number;
    readonly startIndex: SourceTokenListIndex;
    readonly endIndex: SourceTokenListIndex;
    constructor(tokens: Array<SourceToken>);
    /**
     * Iterate over each token.
     */
    forEach(iterator: (token: SourceToken, index: SourceTokenListIndex, list: SourceTokenList) => void): void;
    /**
     * Map each token to an element of an array.
     */
    map<T>(mapper: (token: SourceToken, index: SourceTokenListIndex, list: SourceTokenList) => T): Array<T>;
    /**
     * Filter tokens by a predicate.
     */
    filter(predicate: (token: SourceToken, index: SourceTokenListIndex, list: SourceTokenList) => boolean): SourceTokenList;
    /**
     * Get a slice of this token list using the given indexes.
     */
    slice(start: SourceTokenListIndex, end: SourceTokenListIndex): SourceTokenList;
    /**
     * Get the token at the given index, if it exists.
     *
     * NOTE: The only value for which this should return `null` is this list's
     * `endIndex`.
     */
    tokenAtIndex(index: SourceTokenListIndex): SourceToken | null;
    /**
     * Get the range of tokens representing an interpolated string that contains
     * the token at `index`. This will return the innermost interpolated string in
     * the case of nesting.
     */
    rangeOfInterpolatedStringTokensContainingTokenIndex(index: SourceTokenListIndex): SourceTokenListIndexRange | null;
    /**
     * Get the range of tokens starting with a token of type `startType` and
     * ending one past a token of type `endType`, ensuring that the tokens match.
     * That is, it ensures they are balanced and properly account for nesting.
     * This range will contain `index`. If no such range can be found, `null` is
     * returned.
     */
    rangeOfMatchingTokensContainingTokenIndex(startType: SourceType, endType: SourceType, index: SourceTokenListIndex): SourceTokenListIndexRange | null;
    /**
     * Finds the index of the token whose source range includes the given index.
     * If the given index does not correspond to the range of a token, returns
     * null.
     */
    indexOfTokenContainingSourceIndex(index: number): SourceTokenListIndex | null;
    /**
     * If the given source index lands on a token, return the index of that token.
     * Otherwise, return the index of the previous token in the source code, or
     * the first token if there is no previous token.
     */
    indexOfTokenNearSourceIndex(index: number): SourceTokenListIndex;
    /**
     * Finds the index of the token whose source range starts at the given index.
     */
    indexOfTokenStartingAtSourceIndex(index: number): SourceTokenListIndex | null;
    /**
     * Finds the index of the token whose source range ends at the given index.
     */
    indexOfTokenEndingAtSourceIndex(index: number): SourceTokenListIndex | null;
    /**
     * Finds the index of the first token matching a predicate.
     */
    indexOfTokenMatchingPredicate(predicate: (token: SourceToken) => boolean, start?: SourceTokenListIndex | null, end?: SourceTokenListIndex | null): SourceTokenListIndex | null;
    /**
     * Finds the index of the first token matching a predicate, traversing
     * backwards.
     */
    lastIndexOfTokenMatchingPredicate(predicate: (token: SourceToken) => boolean, start?: SourceTokenListIndex | null, end?: SourceTokenListIndex | null): SourceTokenListIndex | null;
    /**
     * Allow iterating over the tokens in this list using e.g. `for (… of …)`.
     */
    [Symbol.iterator](): () => {
        done: boolean;
        value: SourceToken | null | undefined;
    };
    /**
     * @internal
     */
    private _validateTokens(tokens);
    /**
     * @internal
     */
    private _validateIndex(index);
    /**
     * @internal
     */
    private _validateSourceIndex(index);
    /**
     * @internal
     */
    private _getIndex(index);
    /**
     * Get the list of tokens.
     */
    toArray(): Array<SourceToken>;
}
