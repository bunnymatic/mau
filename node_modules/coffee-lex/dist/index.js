"use strict";
exports.__esModule = true;
var SourceLocation_1 = require("./SourceLocation");
var SourceToken_1 = require("./SourceToken");
var SourceTokenList_1 = require("./SourceTokenList");
var SourceType_1 = require("./SourceType");
exports.SourceType = SourceType_1["default"];
var BufferedStream_1 = require("./utils/BufferedStream");
var calculateHeregexpPadding_1 = require("./utils/calculateHeregexpPadding");
var calculateNormalStringPadding_1 = require("./utils/calculateNormalStringPadding");
var calculateTripleQuotedStringPadding_1 = require("./utils/calculateTripleQuotedStringPadding");
/**
 * Generate a list of tokens from CoffeeScript source code.
 */
function lex(source) {
    var location;
    var previousLocation;
    var tokens = [];
    var pending = new BufferedStream_1["default"](stream(source));
    do {
        pending.unshift.apply(pending, calculateNormalStringPadding_1["default"](source, pending));
        pending.unshift.apply(pending, calculateTripleQuotedStringPadding_1["default"](source, pending));
        pending.unshift.apply(pending, calculateHeregexpPadding_1["default"](source, pending));
        pending.unshift.apply(pending, combinedLocationsForMultiwordOperators(pending, source));
        location = pending.shift();
        if (previousLocation && previousLocation.type !== SourceType_1["default"].SPACE) {
            tokens.push(new SourceToken_1["default"](previousLocation.type, previousLocation.index, location.index));
        }
        previousLocation = location;
    } while (location.type !== SourceType_1["default"].EOF);
    return new SourceTokenList_1["default"](tokens);
}
exports["default"] = lex;
function combinedLocationsForMultiwordOperators(stream, source) {
    if (!stream.hasNext(SourceType_1["default"].OPERATOR, SourceType_1["default"].SPACE, SourceType_1["default"].OPERATOR) && !stream.hasNext(SourceType_1["default"].OPERATOR, SourceType_1["default"].SPACE, SourceType_1["default"].RELATION)) {
        return [];
    }
    var not = stream.shift();
    var space = stream.shift();
    var operator = stream.shift();
    var next = stream.peek();
    if (source.slice(not.index, space.index) === 'not') {
        var op = source.slice(operator.index, next.index);
        switch (op) {
            case 'in':
            case 'of':
                return [
                    new SourceLocation_1["default"](SourceType_1["default"].RELATION, not.index)
                ];
            case 'instanceof':
                return [
                    new SourceLocation_1["default"](SourceType_1["default"].OPERATOR, not.index)
                ];
        }
    }
    // Doesn't match, so put them back.
    return [not, space, operator];
}
var REGEXP_FLAGS = ['i', 'g', 'm', 'y'];
/**
 * Borrowed, with tweaks, from CoffeeScript's lexer.coffee.
 */
var STRING = [SourceType_1["default"].SSTRING_END, SourceType_1["default"].DSTRING_END, SourceType_1["default"].TSSTRING_END, SourceType_1["default"].TDSTRING_END];
var CALLABLE = [
    SourceType_1["default"].IDENTIFIER, SourceType_1["default"].CALL_END, SourceType_1["default"].RPAREN, SourceType_1["default"].RBRACKET, SourceType_1["default"].EXISTENCE, SourceType_1["default"].AT, SourceType_1["default"].THIS, SourceType_1["default"].SUPER
];
var INDEXABLE = CALLABLE.concat([
    SourceType_1["default"].NUMBER
].concat(STRING, [
    SourceType_1["default"].REGEXP, SourceType_1["default"].HEREGEXP_END,
    SourceType_1["default"].BOOL, SourceType_1["default"].NULL, SourceType_1["default"].UNDEFINED, SourceType_1["default"].RBRACE, SourceType_1["default"].PROTO
]));
var NOT_REGEXP = INDEXABLE.concat([SourceType_1["default"].INCREMENT, SourceType_1["default"].DECREMENT]);
var IDENTIFIER_PATTERN = /^(?!\d)((?:(?!\s)[$\w\x7f-\uffff])+)/;
var NUMBER_PATTERN = /^0b[01]+|^0o[0-7]+|^0x[\da-f]+|^\d*\.?\d+(?:e[+-]?\d+)?/i;
var SPACE_PATTERN = /^[^\n\r\S]+/;
var REGEXP_PATTERN = /^\/(?!\/)((?:[^[\/\n\\]|\\[^\n]|\[(?:\\[^\n]|[^\]\n\\])*\])*)(\/)?/;
var YIELDFROM_PATTERN = /^yield[^\n\r\S]+from/;
var OPERATORS = [
    // equality
    '===', '==', '!==', '!=',
    // assignment
    '=',
    '+=', '-=', '/=', '*=', '%=', '%%=',
    '||=', '&&=', '^=', 'or=', 'and=',
    '?=',
    '|=', '&=', '~=', '<<=', '>>>=', '>>=',
    // increment/decrement
    '++', '--',
    // math
    '+', '-', '//', '/', '*', '%', '%%',
    // logical
    '||', '&&', '^', '!',
    // existence
    '?',
    // bitwise
    '|', '&', '~', '<<', '>>>', '>>',
    // comparison
    '<=', '<', '>=', '>',
    // prototype access
    '::',
];
/**
 * Provides a stream of source type change locations.
 */
function stream(source, index) {
    if (index === void 0) { index = 0; }
    var location = new SourceLocation_1["default"](SourceType_1["default"].NORMAL, index);
    var interpolationStack = [];
    var braceStack = [];
    var parenStack = [];
    var stringStack = [];
    var start = index;
    var locations = [];
    return function step() {
        var lastLocation = location;
        var shouldStepAgain = false;
        do {
            start = index;
            if (index >= source.length) {
                setType(SourceType_1["default"].EOF);
            }
            switch (location.type) {
                case SourceType_1["default"].NORMAL:
                case SourceType_1["default"].SPACE:
                case SourceType_1["default"].IDENTIFIER:
                case SourceType_1["default"].DOT:
                case SourceType_1["default"].NUMBER:
                case SourceType_1["default"].OPERATOR:
                case SourceType_1["default"].INCREMENT:
                case SourceType_1["default"].DECREMENT:
                case SourceType_1["default"].COMMA:
                case SourceType_1["default"].LPAREN:
                case SourceType_1["default"].RPAREN:
                case SourceType_1["default"].CALL_START:
                case SourceType_1["default"].CALL_END:
                case SourceType_1["default"].NEW:
                case SourceType_1["default"].LBRACE:
                case SourceType_1["default"].RBRACE:
                case SourceType_1["default"].LBRACKET:
                case SourceType_1["default"].RBRACKET:
                case SourceType_1["default"].NEWLINE:
                case SourceType_1["default"].COLON:
                case SourceType_1["default"].FUNCTION:
                case SourceType_1["default"].THIS:
                case SourceType_1["default"].AT:
                case SourceType_1["default"].SEMICOLON:
                case SourceType_1["default"].IF:
                case SourceType_1["default"].ELSE:
                case SourceType_1["default"].THEN:
                case SourceType_1["default"].FOR:
                case SourceType_1["default"].OWN:
                case SourceType_1["default"].WHILE:
                case SourceType_1["default"].BOOL:
                case SourceType_1["default"].NULL:
                case SourceType_1["default"].UNDEFINED:
                case SourceType_1["default"].REGEXP:
                case SourceType_1["default"].SSTRING_END:
                case SourceType_1["default"].DSTRING_END:
                case SourceType_1["default"].TSSTRING_END:
                case SourceType_1["default"].TDSTRING_END:
                case SourceType_1["default"].INTERPOLATION_START:
                case SourceType_1["default"].SUPER:
                case SourceType_1["default"].TRY:
                case SourceType_1["default"].CATCH:
                case SourceType_1["default"].FINALLY:
                case SourceType_1["default"].SWITCH:
                case SourceType_1["default"].WHEN:
                case SourceType_1["default"].BREAK:
                case SourceType_1["default"].CONTINUE:
                case SourceType_1["default"].EXISTENCE:
                case SourceType_1["default"].CLASS:
                case SourceType_1["default"].PROTO:
                case SourceType_1["default"].RANGE:
                case SourceType_1["default"].DELETE:
                case SourceType_1["default"].RETURN:
                case SourceType_1["default"].RELATION:
                case SourceType_1["default"].LOOP:
                case SourceType_1["default"].DO:
                case SourceType_1["default"].YIELD:
                case SourceType_1["default"].YIELDFROM:
                case SourceType_1["default"].THROW:
                case SourceType_1["default"].EXTENDS:
                case SourceType_1["default"].CONTINUATION:
                    if (consume(SPACE_PATTERN)) {
                        setType(SourceType_1["default"].SPACE);
                    }
                    else if (consume('\n')) {
                        setType(SourceType_1["default"].NEWLINE);
                    }
                    else if (consume('...') || consume('..')) {
                        setType(SourceType_1["default"].RANGE);
                    }
                    else if (consume(NUMBER_PATTERN)) {
                        setType(SourceType_1["default"].NUMBER);
                    }
                    else if (consume('.')) {
                        setType(SourceType_1["default"].DOT);
                    }
                    else if (consume('"""')) {
                        stringStack.push({
                            allowInterpolations: true,
                            endingDelimiter: '"""',
                            endSourceType: SourceType_1["default"].TDSTRING_END
                        });
                        setType(SourceType_1["default"].TDSTRING_START);
                    }
                    else if (consume('"')) {
                        stringStack.push({
                            allowInterpolations: true,
                            endingDelimiter: '"',
                            endSourceType: SourceType_1["default"].DSTRING_END
                        });
                        setType(SourceType_1["default"].DSTRING_START);
                    }
                    else if (consume('\'\'\'')) {
                        stringStack.push({
                            allowInterpolations: false,
                            endingDelimiter: '\'\'\'',
                            endSourceType: SourceType_1["default"].TSSTRING_END
                        });
                        setType(SourceType_1["default"].TSSTRING_START);
                    }
                    else if (consume('\'')) {
                        stringStack.push({
                            allowInterpolations: false,
                            endingDelimiter: '\'',
                            endSourceType: SourceType_1["default"].SSTRING_END
                        });
                        setType(SourceType_1["default"].SSTRING_START);
                    }
                    else if (consume(/^###[^#]/)) {
                        setType(SourceType_1["default"].HERECOMMENT);
                    }
                    else if (consume('#')) {
                        setType(SourceType_1["default"].COMMENT);
                    }
                    else if (consume('///')) {
                        stringStack.push({
                            allowInterpolations: true,
                            endingDelimiter: '///',
                            endSourceType: SourceType_1["default"].HEREGEXP_END
                        });
                        setType(SourceType_1["default"].HEREGEXP_START);
                    }
                    else if (consume('(')) {
                        if (CALLABLE.indexOf(location.type) >= 0) {
                            parenStack.push(SourceType_1["default"].CALL_START);
                            setType(SourceType_1["default"].CALL_START);
                        }
                        else {
                            parenStack.push(SourceType_1["default"].LPAREN);
                            setType(SourceType_1["default"].LPAREN);
                        }
                    }
                    else if (consume(')')) {
                        if (parenStack.length === 0) {
                            throw new Error("unexpected ')' at " + start);
                        }
                        else {
                            var lparen = parenStack.pop();
                            switch (lparen) {
                                case SourceType_1["default"].LPAREN:
                                    setType(SourceType_1["default"].RPAREN);
                                    break;
                                case SourceType_1["default"].CALL_START:
                                    setType(SourceType_1["default"].CALL_END);
                                    break;
                                default:
                                    throw new Error("unexpected token type for '(' matching ')' at " + start + ": " + (lparen ? lparen.toString() : '??'));
                            }
                        }
                    }
                    else if (consume('[')) {
                        setType(SourceType_1["default"].LBRACKET);
                    }
                    else if (consume(']')) {
                        setType(SourceType_1["default"].RBRACKET);
                    }
                    else if (consume('{')) {
                        braceStack.push(start);
                        setType(SourceType_1["default"].LBRACE);
                    }
                    else if (consume('}')) {
                        if (braceStack.length === 0) {
                            popInterpolation();
                        }
                        else {
                            braceStack.pop();
                            setType(SourceType_1["default"].RBRACE);
                        }
                    }
                    else if (consumeAny(['->', '=>'])) {
                        setType(SourceType_1["default"].FUNCTION);
                    }
                    else if (consumeRegexp()) {
                        setType(SourceType_1["default"].REGEXP);
                    }
                    else if (consume('::')) {
                        setType(SourceType_1["default"].PROTO);
                    }
                    else if (consume(':')) {
                        setType(SourceType_1["default"].COLON);
                    }
                    else if (consume(',')) {
                        setType(SourceType_1["default"].COMMA);
                    }
                    else if (consume('@')) {
                        setType(SourceType_1["default"].AT);
                    }
                    else if (consume(';')) {
                        setType(SourceType_1["default"].SEMICOLON);
                    }
                    else if (consume('`')) {
                        setType(SourceType_1["default"].JS);
                    }
                    else if (consumeAny(OPERATORS)) {
                        if (consumed() === '?') {
                            setType(SourceType_1["default"].EXISTENCE);
                        }
                        else if (consumed() === '++') {
                            setType(SourceType_1["default"].INCREMENT);
                        }
                        else if (consumed() === '--') {
                            setType(SourceType_1["default"].DECREMENT);
                        }
                        else {
                            setType(SourceType_1["default"].OPERATOR);
                        }
                    }
                    else if (consume(YIELDFROM_PATTERN)) {
                        setType(SourceType_1["default"].YIELDFROM);
                    }
                    else if (consume(IDENTIFIER_PATTERN)) {
                        var prevLocationIndex = locations.length - 1;
                        while (prevLocationIndex > 0 && locations[prevLocationIndex].type === SourceType_1["default"].NEWLINE) {
                            prevLocationIndex--;
                        }
                        var prev = locations[prevLocationIndex];
                        var nextIsColon = match(/^\s*:/);
                        if (nextIsColon || (prev && (prev.type === SourceType_1["default"].DOT || prev.type === SourceType_1["default"].PROTO || prev.type === SourceType_1["default"].AT))) {
                            setType(SourceType_1["default"].IDENTIFIER);
                        }
                        else {
                            switch (consumed()) {
                                case 'if':
                                case 'unless':
                                    setType(SourceType_1["default"].IF);
                                    break;
                                case 'else':
                                    setType(SourceType_1["default"].ELSE);
                                    break;
                                case 'return':
                                    setType(SourceType_1["default"].RETURN);
                                    break;
                                case 'for':
                                    setType(SourceType_1["default"].FOR);
                                    break;
                                case 'own':
                                    setType(SourceType_1["default"].OWN);
                                    break;
                                case 'while':
                                case 'until':
                                    setType(SourceType_1["default"].WHILE);
                                    break;
                                case 'loop':
                                    setType(SourceType_1["default"].LOOP);
                                    break;
                                case 'then':
                                    setType(SourceType_1["default"].THEN);
                                    break;
                                case 'switch':
                                    setType(SourceType_1["default"].SWITCH);
                                    break;
                                case 'when':
                                    setType(SourceType_1["default"].WHEN);
                                    break;
                                case 'null':
                                    setType(SourceType_1["default"].NULL);
                                    break;
                                case 'undefined':
                                    setType(SourceType_1["default"].UNDEFINED);
                                    break;
                                case 'this':
                                    setType(SourceType_1["default"].THIS);
                                    break;
                                case 'new':
                                    setType(SourceType_1["default"].NEW);
                                    break;
                                case 'super':
                                    setType(SourceType_1["default"].SUPER);
                                    break;
                                case 'true':
                                case 'false':
                                case 'yes':
                                case 'no':
                                case 'on':
                                case 'off':
                                    setType(SourceType_1["default"].BOOL);
                                    break;
                                case 'and':
                                case 'or':
                                case 'not':
                                case 'is':
                                case 'isnt':
                                case 'instanceof':
                                    setType(SourceType_1["default"].OPERATOR);
                                    break;
                                case 'class':
                                    setType(SourceType_1["default"].CLASS);
                                    break;
                                case 'break':
                                    setType(SourceType_1["default"].BREAK);
                                    break;
                                case 'continue':
                                    setType(SourceType_1["default"].CONTINUE);
                                    break;
                                case 'try':
                                    setType(SourceType_1["default"].TRY);
                                    break;
                                case 'catch':
                                    setType(SourceType_1["default"].CATCH);
                                    break;
                                case 'finally':
                                    setType(SourceType_1["default"].FINALLY);
                                    break;
                                case 'delete':
                                    setType(SourceType_1["default"].DELETE);
                                    break;
                                case 'in':
                                case 'of':
                                    setType(SourceType_1["default"].RELATION);
                                    break;
                                case 'do':
                                    setType(SourceType_1["default"].DO);
                                    break;
                                case 'yield':
                                    setType(SourceType_1["default"].YIELD);
                                    break;
                                case 'throw':
                                    setType(SourceType_1["default"].THROW);
                                    break;
                                case 'extends':
                                    setType(SourceType_1["default"].EXTENDS);
                                    break;
                                default:
                                    setType(SourceType_1["default"].IDENTIFIER);
                            }
                        }
                    }
                    else if (consume('\\')) {
                        setType(SourceType_1["default"].CONTINUATION);
                    }
                    else {
                        setType(SourceType_1["default"].UNKNOWN);
                    }
                    break;
                case SourceType_1["default"].SSTRING_START:
                case SourceType_1["default"].DSTRING_START:
                case SourceType_1["default"].TSSTRING_START:
                case SourceType_1["default"].TDSTRING_START:
                case SourceType_1["default"].HEREGEXP_START:
                    setType(SourceType_1["default"].STRING_CONTENT);
                    break;
                case SourceType_1["default"].STRING_CONTENT: {
                    var stringOptions = stringStack[stringStack.length - 1];
                    if (!stringOptions) {
                        throw new Error('Unexpected STRING_CONTENT without anything on the string stack.');
                    }
                    if (consume('\\')) {
                        index++;
                    }
                    else if (consume(stringOptions.endingDelimiter)) {
                        stringStack.pop();
                        setType(stringOptions.endSourceType);
                    }
                    else if (stringOptions.allowInterpolations && consume('#{')) {
                        pushInterpolation();
                    }
                    else {
                        index++;
                    }
                    break;
                }
                case SourceType_1["default"].COMMENT:
                    if (consume('\n')) {
                        setType(SourceType_1["default"].NEWLINE);
                    }
                    else {
                        index++;
                    }
                    break;
                case SourceType_1["default"].HERECOMMENT:
                    if (consume('###')) {
                        setType(SourceType_1["default"].NORMAL);
                    }
                    else {
                        index++;
                    }
                    break;
                case SourceType_1["default"].INTERPOLATION_END:
                    var lastInterpolation = interpolationStack.pop();
                    if (!lastInterpolation) {
                        throw new Error("found interpolation end without any interpolation start");
                    }
                    var type = lastInterpolation.type, braces = lastInterpolation.braces;
                    setType(type);
                    braceStack = braces;
                    break;
                case SourceType_1["default"].HEREGEXP_END:
                    while (consumeAny(REGEXP_FLAGS)) {
                        // condition has side-effect
                    }
                    setType(SourceType_1["default"].NORMAL);
                    break;
                case SourceType_1["default"].JS:
                    if (consume('\\')) {
                        index++;
                    }
                    else if (consume('`')) {
                        setType(SourceType_1["default"].NORMAL);
                    }
                    else {
                        index++;
                    }
                    break;
                case SourceType_1["default"].EOF:
                    if (braceStack.length !== 0) {
                        throw new Error("unexpected EOF while looking for '}' to match '{' " +
                            ("at " + braceStack[braceStack.length - 1]));
                    }
                    if (stringStack.length !== 0) {
                        throw new Error('unexpected EOF while parsing a string');
                    }
                    break;
                case SourceType_1["default"].UNKNOWN:
                    // Jump to the end.
                    index = source.length;
                    break;
                default:
                    throw new Error("unknown source type at offset " + location.index + ": " + SourceType_1["default"][location.type]);
            }
            shouldStepAgain = (
            // Don't report on going back to "normal" source code.
            location.type === SourceType_1["default"].NORMAL ||
                // Don't report if nothing has changed, unless we're at the end.
                (location === lastLocation &&
                    location.type !== SourceType_1["default"].EOF));
        } while (shouldStepAgain);
        locations.push(location);
        return location;
    };
    function consumeAny(strings) {
        return strings.some(function (string) { return consume(string); });
    }
    function consume(value) {
        var matchData = match(value);
        if (matchData) {
            index += matchData[0].length;
            return true;
        }
        else {
            return false;
        }
    }
    function consumeRegexp() {
        var matchData = match(REGEXP_PATTERN);
        if (!matchData) {
            return false;
        }
        var regex = matchData[0], closed = matchData[2];
        var prev = locations[locations.length - 1];
        if (prev) {
            var spaced = false;
            if (prev.type === SourceType_1["default"].SPACE) {
                spaced = true;
                prev = locations[locations.length - 2];
            }
            if (spaced && CALLABLE.indexOf(prev.type) >= 0) {
                if (!closed || /^\/=?\s/.test(regex)) {
                    return false;
                }
            }
            else if (NOT_REGEXP.indexOf(prev.type) >= 0) {
                return false;
            }
        }
        if (!closed) {
            throw new Error('missing / (unclosed regex)');
        }
        index += regex.length;
        while (consumeAny(REGEXP_FLAGS)) {
            // condition has side-effect
        }
        return true;
    }
    function consumed() {
        return source.slice(start, index);
    }
    function setType(newType) {
        location = new SourceLocation_1["default"](newType, start);
    }
    function match(value) {
        if (typeof value === 'string') {
            var matches = source.slice(index, index + value.length) === value;
            return matches ? [value] : null;
        }
        else {
            return source.slice(index).match(value);
        }
    }
    function pushInterpolation() {
        interpolationStack.push({ type: location.type, braces: braceStack });
        setType(SourceType_1["default"].INTERPOLATION_START);
        braceStack = [];
    }
    function popInterpolation() {
        if (interpolationStack.length === 0) {
            throw new Error("unexpected '}' found in string at " + index + ": " + JSON.stringify(source));
        }
        setType(SourceType_1["default"].INTERPOLATION_END);
    }
}
exports.stream = stream;
function consumeStream(lexer) {
    var result = [];
    var location;
    do {
        location = lexer();
        result.push(location);
    } while (location.type !== SourceType_1["default"].EOF);
    return result;
}
exports.consumeStream = consumeStream;
