import SourceType from '../SourceType';
import PaddingTracker from './PaddingTracker';
/**
 * Compute the whitespace to remove in a heregexp. All unescaped whitespace
 * characters are removed, and comments are respected.
 */
export default function calculateHeregexpPadding(source, stream) {
    if (!stream.hasNext(SourceType.HEREGEXP_START)) {
        return [];
    }
    var paddingTracker = new PaddingTracker(source, stream, SourceType.HEREGEXP_END);
    for (var _i = 0, _a = paddingTracker.fragments; _i < _a.length; _i++) {
        var fragment = _a[_i];
        var content = fragment.content;
        var pos = 0;
        while (pos < content.length) {
            if (/\s/.test(content[pos])) {
                if (isWhitespaceEscaped(content, pos)) {
                    // The escape character should be removed instead of the space.
                    fragment.markPadding(pos - 1, pos);
                }
                else {
                    fragment.markPadding(pos, pos + 1);
                }
                pos++;
            }
            else if (content[pos] === '#' && (pos === 0 || /\s/.test(content[pos - 1]))) {
                var commentStart = pos;
                while (pos < content.length && content[pos] !== '\n') {
                    pos++;
                }
                fragment.markPadding(commentStart, pos);
            }
            else {
                pos++;
            }
        }
    }
    return paddingTracker.computeSourceLocations();
}
/**
 * A space, tab, or newline is escaped if it is preceded by an odd number of
 * backslashes.
 */
function isWhitespaceEscaped(content, whitespacePos) {
    var prevPos = whitespacePos - 1;
    while (prevPos >= 0 && content[prevPos] === '\\') {
        prevPos--;
    }
    return (whitespacePos - prevPos) % 2 === 0;
}
