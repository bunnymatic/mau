import SourceLocation from '../SourceLocation';
import SourceType from '../SourceType';
/**
 * Helper class for defining the padding (characters to remove, typically
 * whitespace) in a string or heregexp. Also tracks "line separators", which are
 * newline characters in multiline single and double quoted strings that should
 * be turned into space characters.
 *
 * Example usage:
 *
 * let paddingTracker = new PaddingTracker(source, stream, SSTRING_END);
 *
 * // Examine underlying code to see what padding to add.
 * paddingTracker.fragments[0].content;
 *
 * // Mark padding for each fragment, indexed relative to the fragment content.
 * paddingTracker.fragments[0].markPadding(3, 5);
 * paddingTracker.fragments[1].markPadding(1, 4);
 * paddingTracker.fragments[1].markLineSeparator(5);
 *
 * // Compute the replacement source locations for the entire string/heregexp.
 * paddingTracker.computeSourceLocations();
 */
var PaddingTracker = (function () {
    function PaddingTracker(source, stream, endType) {
        this.fragments = [];
        this._originalLocations = [];
        var interpolationLevel = 0;
        var location;
        do {
            location = stream.shift();
            this._originalLocations.push(location);
            if (interpolationLevel === 0 && location.type === SourceType.STRING_CONTENT) {
                var start = location.index;
                var end = stream.peek().index;
                var content = source.slice(start, end);
                var index = this.fragments.length;
                this.fragments.push(new TrackedFragment(content, start, end, index));
            }
            else if (location.type === SourceType.INTERPOLATION_START) {
                interpolationLevel += 1;
            }
            else if (location.type === SourceType.INTERPOLATION_END) {
                interpolationLevel -= 1;
            }
        } while (interpolationLevel > 0 || location.type !== endType);
    }
    PaddingTracker.prototype.computeSourceLocations = function () {
        var resultLocations = [];
        var rangeIndex = 0;
        for (var _i = 0, _a = this._originalLocations; _i < _a.length; _i++) {
            var location = _a[_i];
            var currentRange = this.fragments[rangeIndex];
            if (location.type === SourceType.STRING_CONTENT &&
                currentRange && location.index === currentRange.start) {
                resultLocations.push.apply(resultLocations, currentRange.computeSourceLocations());
                rangeIndex++;
            }
            else {
                resultLocations.push(location);
            }
        }
        if (rangeIndex !== this.fragments.length) {
            throw new Error('Expected ranges to correspond to original locations.');
        }
        return resultLocations;
    };
    return PaddingTracker;
}());
export default PaddingTracker;
var TrackedFragment = (function () {
    function TrackedFragment(content, start, end, index) {
        this.content = content;
        this.start = start;
        this.end = end;
        this.index = index;
        this._paddingRanges = [];
        this._lineSeparators = [];
    }
    TrackedFragment.prototype.markPadding = function (startIndex, endIndex) {
        this._paddingRanges.push({ start: startIndex, end: endIndex });
    };
    TrackedFragment.prototype.markLineSeparator = function (index) {
        this._lineSeparators.push(index);
    };
    TrackedFragment.prototype.computeSourceLocations = function () {
        if (this.start === this.end) {
            return [new SourceLocation(SourceType.STRING_CONTENT, this.start)];
        }
        // Break the marked ranges down into events, similar to how you might count
        // paren nesting. At each index, we can then know if we're inside padding,
        // a line separator, or neither.
        var eventsByIndex = [];
        for (var i = 0; i < this.end - this.start + 1; i++) {
            eventsByIndex.push([]);
        }
        for (var _i = 0, _a = this._paddingRanges; _i < _a.length; _i++) {
            var range = _a[_i];
            eventsByIndex[range.start].push('START_PADDING');
            eventsByIndex[range.end].push('END_PADDING');
        }
        for (var _b = 0, _c = this._lineSeparators; _b < _c.length; _b++) {
            var separatorIndex = _c[_b];
            eventsByIndex[separatorIndex].push('START_LINE_SEPARATOR');
            eventsByIndex[separatorIndex + 1].push('END_LINE_SEPARATOR');
        }
        var resultLocations = [];
        var lastSourceType = null;
        var paddingDepth = 0;
        var lineSeparatorDepth = 0;
        for (var sourceIndex = this.start; sourceIndex < this.end; sourceIndex++) {
            for (var _d = 0, _e = eventsByIndex[sourceIndex - this.start]; _d < _e.length; _d++) {
                var event = _e[_d];
                if (event === 'START_PADDING') {
                    paddingDepth += 1;
                }
                else if (event === 'END_PADDING') {
                    paddingDepth -= 1;
                }
                else if (event === 'START_LINE_SEPARATOR') {
                    lineSeparatorDepth += 1;
                }
                else if (event === 'END_LINE_SEPARATOR') {
                    lineSeparatorDepth -= 1;
                }
            }
            if (paddingDepth < 0 || lineSeparatorDepth < 0 || (paddingDepth > 0 && lineSeparatorDepth > 0)) {
                throw new Error("Illegal padding state: paddingDepth: " + paddingDepth + ", lineSeparatorDepth: " + lineSeparatorDepth);
            }
            var sourceType = void 0;
            if (paddingDepth > 0) {
                sourceType = SourceType.STRING_PADDING;
            }
            else if (lineSeparatorDepth > 0) {
                sourceType = SourceType.STRING_LINE_SEPARATOR;
            }
            else {
                sourceType = SourceType.STRING_CONTENT;
            }
            if (sourceType !== lastSourceType) {
                resultLocations.push(new SourceLocation(sourceType, sourceIndex));
                lastSourceType = sourceType;
            }
        }
        return resultLocations;
    };
    return TrackedFragment;
}());
export { TrackedFragment };
