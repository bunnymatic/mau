import SourceTokenListIndex from './SourceTokenListIndex';
import SourceType from './SourceType';
/**
 * Represents a list of tokens and provides various utility functions for
 * finding tokens within it.
 */
var SourceTokenList = (function () {
    function SourceTokenList(tokens) {
        this._validateTokens(tokens);
        this._tokens = tokens;
        this._indexCache = new Array(tokens.length);
        this.length = tokens.length;
        this.startIndex = this._getIndex(0);
        this.endIndex = this._getIndex(tokens.length);
        // Precompute sparse arrays to do source-to-token mappings later. Iterate
        // backwards through the tokens so that earlier tokens win ties.
        this._indexBySourceIndex = [];
        this._indexByStartSourceIndex = [];
        this._indexByEndSourceIndex = [];
        for (var tokenIndex = tokens.length - 1; tokenIndex >= 0; tokenIndex--) {
            var token = tokens[tokenIndex];
            for (var sourceIndex = token.start; sourceIndex < token.end; sourceIndex++) {
                this._indexBySourceIndex[sourceIndex] = this._getIndex(tokenIndex);
            }
            this._indexByStartSourceIndex[token.start] = this._getIndex(tokenIndex);
            this._indexByEndSourceIndex[token.end] = this._getIndex(tokenIndex);
        }
    }
    /**
     * Iterate over each token.
     */
    SourceTokenList.prototype.forEach = function (iterator) {
        var _this = this;
        this._tokens.forEach(function (token, i) { return iterator(token, _this._getIndex(i), _this); });
    };
    /**
     * Map each token to an element of an array.
     */
    SourceTokenList.prototype.map = function (mapper) {
        var result = [];
        this.forEach(function (token, index, list) { result.push(mapper(token, index, list)); });
        return result;
    };
    /**
     * Filter tokens by a predicate.
     */
    SourceTokenList.prototype.filter = function (predicate) {
        var result = [];
        this.forEach(function (token, index, list) {
            if (predicate(token, index, list)) {
                result.push(token);
            }
        });
        return new SourceTokenList(result);
    };
    /**
     * Get a slice of this token list using the given indexes.
     */
    SourceTokenList.prototype.slice = function (start, end) {
        if (start['_sourceTokenList'] !== this || end['_sourceTokenList'] !== this) {
            throw new Error('cannot slice a list using indexes from another list');
        }
        return new SourceTokenList(this._tokens.slice(start['_index'], end['_index']));
    };
    /**
     * Get the token at the given index, if it exists.
     *
     * NOTE: The only value for which this should return `null` is this list's
     * `endIndex`.
     */
    SourceTokenList.prototype.tokenAtIndex = function (index) {
        this._validateIndex(index);
        return this._tokens[index['_index']] || null;
    };
    /**
     * Get the range of tokens representing an interpolated string that contains
     * the token at `index`. This will return the innermost interpolated string in
     * the case of nesting.
     */
    SourceTokenList.prototype.rangeOfInterpolatedStringTokensContainingTokenIndex = function (index) {
        var bestRange = null;
        for (var _i = 0, _a = [
            [SourceType.DSTRING_START, SourceType.DSTRING_END], [SourceType.TDSTRING_START, SourceType.TDSTRING_END], [SourceType.HEREGEXP_START, SourceType.HEREGEXP_END]
        ]; _i < _a.length; _i++) {
            var _b = _a[_i], startType = _b[0], endType = _b[1];
            var range = this.rangeOfMatchingTokensContainingTokenIndex(startType, endType, index);
            if (bestRange === null || bestRange === undefined ||
                (range !== null && range !== undefined &&
                    range[0].distance(range[1]) < bestRange[0].distance(bestRange[1]))) {
                bestRange = range;
            }
        }
        return bestRange;
    };
    /**
     * Get the range of tokens starting with a token of type `startType` and
     * ending one past a token of type `endType`, ensuring that the tokens match.
     * That is, it ensures they are balanced and properly account for nesting.
     * This range will contain `index`. If no such range can be found, `null` is
     * returned.
     */
    SourceTokenList.prototype.rangeOfMatchingTokensContainingTokenIndex = function (startType, endType, index) {
        this._validateIndex(index);
        var token = this.tokenAtIndex(index);
        if (!token) {
            return null;
        }
        switch (token.type) {
            case startType:
                {
                    var level_1 = 0;
                    var start = index;
                    var endIndex = this.indexOfTokenMatchingPredicate(function (token) {
                        if (token.type === startType) {
                            level_1 += 1;
                        }
                        else if (token.type === endType) {
                            level_1 -= 1;
                            if (level_1 === 0) {
                                return true;
                            }
                        }
                        return false;
                    }, start);
                    if (!endIndex) {
                        return null;
                    }
                    else {
                        var rangeEnd = endIndex.next();
                        if (!rangeEnd) {
                            return null;
                        }
                        return [start, rangeEnd];
                    }
                }
            case endType:
                {
                    var level_2 = 0;
                    var endIndex = index;
                    var startIndex = this.lastIndexOfTokenMatchingPredicate(function (token) {
                        if (token.type === startType) {
                            level_2 -= 1;
                            if (level_2 === 0) {
                                return true;
                            }
                        }
                        else if (token.type === endType) {
                            level_2 += 1;
                        }
                        return false;
                    }, endIndex);
                    if (!startIndex) {
                        return null;
                    }
                    else {
                        var rangeEnd = endIndex.next();
                        if (!rangeEnd) {
                            return null;
                        }
                        else {
                            return [startIndex, rangeEnd];
                        }
                    }
                }
            default:
                {
                    var level_3 = 0;
                    var startIndex = this.lastIndexOfTokenMatchingPredicate(function (token) {
                        if (token.type === startType) {
                            if (level_3 === 0) {
                                return true;
                            }
                            level_3 -= 1;
                        }
                        else if (token.type === endType) {
                            level_3 += 1;
                        }
                        return false;
                    }, index);
                    if (!startIndex) {
                        return null;
                    }
                    else {
                        return this.rangeOfMatchingTokensContainingTokenIndex(startType, endType, startIndex);
                    }
                }
        }
    };
    /**
     * Finds the index of the token whose source range includes the given index.
     * If the given index does not correspond to the range of a token, returns
     * null.
     */
    SourceTokenList.prototype.indexOfTokenContainingSourceIndex = function (index) {
        this._validateSourceIndex(index);
        return this._indexBySourceIndex[index] || null;
    };
    /**
     * If the given source index lands on a token, return the index of that token.
     * Otherwise, return the index of the previous token in the source code, or
     * the first token if there is no previous token.
     */
    SourceTokenList.prototype.indexOfTokenNearSourceIndex = function (index) {
        this._validateSourceIndex(index);
        for (var searchIndex = index; searchIndex >= 0; searchIndex--) {
            var tokenIndex = this._indexBySourceIndex[searchIndex];
            if (tokenIndex) {
                return tokenIndex;
            }
        }
        return this.startIndex;
    };
    /**
     * Finds the index of the token whose source range starts at the given index.
     */
    SourceTokenList.prototype.indexOfTokenStartingAtSourceIndex = function (index) {
        this._validateSourceIndex(index);
        return this._indexByStartSourceIndex[index] || null;
    };
    /**
     * Finds the index of the token whose source range ends at the given index.
     */
    SourceTokenList.prototype.indexOfTokenEndingAtSourceIndex = function (index) {
        this._validateSourceIndex(index);
        return this._indexByEndSourceIndex[index] || null;
    };
    /**
     * Finds the index of the first token matching a predicate.
     */
    SourceTokenList.prototype.indexOfTokenMatchingPredicate = function (predicate, start, end) {
        if (start === void 0) { start = null; }
        if (end === void 0) { end = null; }
        if (!start) {
            start = this.startIndex;
        }
        if (!end) {
            end = this.endIndex;
        }
        this._validateIndex(start);
        this._validateIndex(end);
        for (var i = start; i && i !== end; i = i.next()) {
            var token = this.tokenAtIndex(i);
            if (!token) {
                break;
            }
            else if (predicate(token)) {
                return i;
            }
        }
        return null;
    };
    /**
     * Finds the index of the first token matching a predicate, traversing
     * backwards.
     */
    SourceTokenList.prototype.lastIndexOfTokenMatchingPredicate = function (predicate, start, end) {
        if (start === void 0) { start = null; }
        if (end === void 0) { end = null; }
        if (!start) {
            start = this.endIndex.previous();
            if (!start) {
                return null;
            }
        }
        this._validateIndex(start);
        if (end) {
            this._validateIndex(end);
        }
        var i = start;
        do {
            var token = this.tokenAtIndex(i);
            if (!token) {
                break;
            }
            else if (predicate(token)) {
                return i;
            }
            else if (i) {
                i = i.previous();
            }
        } while (i && i !== end);
        return null;
    };
    /**
     * Allow iterating over the tokens in this list using e.g. `for (… of …)`.
     */
    SourceTokenList.prototype[Symbol.iterator] = function () {
        var _this = this;
        var index = this.startIndex;
        var endIndex = this.endIndex;
        return function () {
            if (index === endIndex) {
                return { done: true, value: undefined };
            }
            else {
                var result = { done: false, value: _this.tokenAtIndex(index) };
                var nextIndex = index.next();
                if (!nextIndex) {
                    throw new Error("unexpected null index before the end index");
                }
                index = nextIndex;
                return result;
            }
        };
    };
    /**
     * @internal
     */
    SourceTokenList.prototype._validateTokens = function (tokens) {
        for (var i = 0; i < tokens.length - 1; i++) {
            if (tokens[i].end > tokens[i + 1].start) {
                throw new Error("Tokens not in order. Expected " + JSON.stringify(tokens[i]) + " before " +
                    ("" + JSON.stringify(tokens[i + 1])));
            }
        }
    };
    /**
     * @internal
     */
    SourceTokenList.prototype._validateIndex = function (index) {
        if (!index) {
            throw new Error("unexpected 'null' index, perhaps you forgot to check the result of " +
                "'indexOfTokenContainingSourceIndex'?");
        }
        if (typeof index === 'number') {
            throw new Error("to get a token at index " + index + ", " +
                ("use list.tokenAtIndex(list.startIndex.advance(" + index + "))"));
        }
        if (index['_sourceTokenList'] !== this) {
            throw new Error('cannot get token in one list using an index from another');
        }
    };
    /**
     * @internal
     */
    SourceTokenList.prototype._validateSourceIndex = function (index) {
        if (typeof index !== 'number') {
            throw new Error("expected source index to be a number, got: " + index);
        }
    };
    /**
     * @internal
     */
    SourceTokenList.prototype._getIndex = function (index) {
        var cached = this._indexCache[index];
        if (!cached) {
            cached = new SourceTokenListIndex(this, index);
            this._indexCache[index] = cached;
        }
        return cached;
    };
    /**
     * Get the list of tokens.
     */
    SourceTokenList.prototype.toArray = function () {
        return this._tokens.slice();
    };
    return SourceTokenList;
}());
export default SourceTokenList;
