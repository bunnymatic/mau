import { parse, tokTypes } from 'babylon';
import MagicString from 'magic-string';
import { NODE_FIELDS, assignmentExpression, exportAllDeclaration, exportDefaultDeclaration, exportNamedDeclaration, exportSpecifier, identifier, importDeclaration, importDefaultSpecifier, importSpecifier, isArrowFunctionExpression, isAssignmentExpression, isBinaryExpression, isCallExpression, isClassMethod, isExpressionStatement, isFunction, isFunctionExpression, isIdentifier, isLogicalExpression, isMemberExpression, isNewExpression, isNode, isObjectExpression, isObjectPattern, isObjectProperty, isProgram, isProperty, isReturnStatement, isSequenceExpression, isStringLiteral, isSwitchCase, isThisExpression, isUnaryExpression, isVariableDeclaration, isVariableDeclarator, objectMethod, objectPattern, objectProperty, stringLiteral, templateElement, templateLiteral, variableDeclaration, variableDeclarator } from 'babel-types';
import * as t from 'babel-types';
import { inspect } from 'util';
import shebangRegex from 'shebang-regex';
import traverse from 'babel-traverse';
import { basename, dirname } from 'path';
import { createReadStream, createWriteStream } from 'fs';
import mkdirp from 'mkdirp';

function clone(object) {
  return JSON.parse(JSON.stringify(object));
}

var BABEL_PARSE_OPTIONS = {
  sourceType: 'module',
  strictMode: true,
  allowImportExportEverywhere: false, // consistent with espree
  allowReturnOutsideFunction: true,
  allowSuperOutsideMethod: true,
  plugins: ['flow', 'jsx', 'asyncFunctions', 'asyncGenerators', 'classConstructorCall', 'classProperties', 'decorators', 'doExpressions', 'exponentiationOperator', 'exportExtensions', 'functionBind', 'functionSent', 'objectRestSpread', 'trailingFunctionCommas', 'optionalChaining'],
  tokens: true
};

Object.defineProperty(tokTypes.backQuote, 'updateContext', {
  value: tokTypes.backQuote.updateContext,
  configurable: false
});

var parse$1 = function (source) {
  return parse(source, BABEL_PARSE_OPTIONS);
};

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();









var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};





var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();













var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

var Module = function () {
  function Module(id, source) {
    classCallCheck(this, Module);
    this.metadata = {};
    this.warnings = [];

    this.id = id;
    this.reinit(source);
  }

  /**
   * @private
   */


  createClass(Module, [{
    key: 'reinit',
    value: function reinit(source) {
      this.source = source;
      this.ast = parse$1(source);
      this.tokens = this.ast.tokens;
      this.magicString = new MagicString(source, {
        filename: this.id
      });
    }
  }, {
    key: 'commit',
    value: function commit() {
      var source = this.magicString.toString();

      if (source !== this.source) {
        this.reinit(source);
      }
    }
  }, {
    key: 'warn',
    value: function warn(node, type, message) {
      this.warnings.push({ node: clone(node), type: type, message: message });
    }
  }, {
    key: 'tokensForNode',
    value: function tokensForNode(node) {
      return this.tokensInRange(node.start, node.end);
    }
  }, {
    key: 'tokensInRange',
    value: function tokensInRange(start, end) {
      var tokenRange = this.tokenIndexRangeForSourceRange(start, end);

      if (!tokenRange) {
        return [];
      }

      return this.tokens.slice(tokenRange.start, tokenRange.end);
    }
  }, {
    key: 'tokenIndexRangeForSourceRange',
    value: function tokenIndexRangeForSourceRange(start, end) {
      var location = null;
      var length = 0;
      var tokens = this.tokens;

      for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i];
        if (token.end > end) {
          break;
        } else if (token.start >= start) {
          if (location === null) {
            location = i;
          }
          length++;
        }
      }

      if (location === null) {
        return null;
      }

      return { start: location, end: location + length };
    }
  }, {
    key: 'render',
    value: function render() {
      return {
        code: this.magicString.toString(),
        ast: this.ast,
        warnings: this.warnings.slice(),
        metadata: this.metadata
      };
    }
  }, {
    key: 'sourceOf',
    value: function sourceOf(node) {
      return this.source.slice(node.start, node.end);
    }
  }]);
  return Module;
}();

function cleanNode(node) {
  if (!isNode(node)) {
    throw new Error('node must be a valid node type, got: ' + inspect(node));
  }

  var result = Object.create(null);
  var fields = NODE_FIELDS[node.type];

  result.type = node.type;

  Object.keys(fields).forEach(function (field) {
    if (field in node) {
      var value = node[field];

      if (isNode(value)) {
        result[field] = cleanNode(value);
      } else if (Array.isArray(value)) {
        result[field] = value.map(function (element) {
          return isNode(element) ? cleanNode(element) : element;
        });
      } else {
        result[field] = value;
      }
    } else {
      result[field] = fields[field].default;
    }
  });

  return result;
}

function replace(destination, source) {
  for (var key in destination) {
    delete destination[key];
  }

  for (var _key in source) {
    destination[_key] = source[_key];
  }

  return destination;
}

function hasParens(path$$1, module) {
  var tokens = module.tokens;

  var _module$tokenIndexRan = module.tokenIndexRangeForSourceRange(path$$1.node.start, path$$1.node.end),
      start = _module$tokenIndexRan.start,
      end = _module$tokenIndexRan.end;

  var tokenBefore = tokens[start - 1];
  var tokenAfter = tokens[end];

  return tokenBefore.type.label === '(' && tokenAfter.type.label === ')';
}

function needsParens(path$$1) {
  var node = path$$1.node,
      parent = path$$1.parent;


  if (isArrowFunctionExpression(node)) {
    if (isMemberExpression(parent)) {
      return parent.object === node;
    } else if (isCallExpression(parent)) {
      return parent.callee === node;
    } else if (isBinaryExpression(parent)) {
      return true;
    } else if (isLogicalExpression(parent)) {
      return true;
    }
  }

  return false;
}

function indexOfElementMatchingPredicate(list, predicate) {
  var start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

  var index = start;
  while (index < list.length) {
    var _element = list[index];
    if (predicate(_element)) {
      return index;
    }
    index++;
  }
  return ~index;
}

function findToken(label, tokens) {
  var start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

  return findTokenMatchingPredicate(function (token) {
    return token.type.label === label;
  }, tokens, start);
}

function findTokenMatchingPredicate(predicate, tokens) {
  var start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

  var index = indexOfElementMatchingPredicate(tokens, predicate, start);
  if (index < 0) {
    var loc = tokens[start].loc.start;
    throw new Error('unexpected token after ' + loc.line + ':' + (loc.column + 1));
  }
  return { index: index, token: tokens[index] };
}

function findEndBraceTokenBalanced(tokens) {
  var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

  // We count '{' and '${' as left tokens because string interpolations start
  // with '${' and end with the same '}' as objects and blocks.
  return findEndTokenBalanced(['{', '${'], '}', tokens, start);
}

function findEndParenthesisTokenBalanced(tokens) {
  var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

  return findEndTokenBalanced('(', ')', tokens, start);
}

function findEndTokenBalanced(left, right, tokens) {
  var start = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

  var index = indexOfBalancedToken(tokens, tokenMatcher(left), tokenMatcher(right), start);
  if (index < 0) {
    var loc = tokens[start].loc.start;
    throw new Error('expected balanced tokens starting at ' + loc.line + ':' + (loc.column + 1));
  }
  return { index: index, token: tokens[index] };
}

function tokenMatcher(label) {
  if (typeof label === 'string') {
    return function (token) {
      return token.type.label === label;
    };
  } else {
    return function (token) {
      return label.indexOf(token.type.label) >= 0;
    };
  }
}

function indexOfBalancedToken(tokens, leftPredicate, rightPredicate) {
  var start = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

  var depth = 0;
  return indexOfElementMatchingPredicate(tokens, function (token) {
    if (leftPredicate(token)) {
      depth++;
    }
    if (rightPredicate(token)) {
      depth--;
    }
    return depth === 0;
  }, start);
}

var name = 'functions.arrow';
var description = 'Transform regular functions to arrow functions as appropriate.';

function visitor(module) {
  var editor = module.magicString;
  var functions = metadata(module).functions;

  return {
    FunctionExpression: function FunctionExpression(path$$1) {
      var node = path$$1.node,
          parent = path$$1.parent;

      // Skip generator functions.

      if (node.generator) {
        return;
      }

      // Only process anonymous functions.
      if (node.id) {
        return;
      }

      // Skip object literal methods.
      if (isProperty(parent) && parent.method) {
        return;
      }

      // Skip class methods.
      if (isClassMethod(parent) && parent.value === node) {
        return;
      }

      // Only process functions with a single return statement.
      if (node.body.body.length !== 1) {
        return;
      }

      // A directive like "use strict" is syntactically its own line, so if any
      // exist, we can't assume this is a single-line function.
      if (node.body.directives.length > 0) {
        return;
      }

      // `new` can't be called on arrow functions.
      if (isNewExpression(parent)) {
        return;
      }

      var _node$body$body = slicedToArray(node.body.body, 1),
          statement = _node$body$body[0];

      if (!isReturnStatement(statement) || !statement.argument) {
        return;
      }

      // Skip functions referencing `this` or `arguments`.
      if (referencesThisOrArguments(path$$1)) {
        return;
      }

      rewriteBlocklessArrowFunction(path$$1, module, functions);

      // Remove extra parentheses if they're no longer needed.
      if (isExpressionStatement(parent) && hasParens(path$$1, module)) {
        var _module$tokenIndexRan = module.tokenIndexRangeForSourceRange(node.start, node.end),
            start = _module$tokenIndexRan.start,
            end = _module$tokenIndexRan.end;

        var tokens = module.tokens;

        var lparen = tokens[start - 1];
        var rparen = tokens[end];
        editor.remove(lparen.start, node.start);
        editor.remove(node.end, rparen.end);
      }
    },


    /**
     * Look for functions that are manually bound, e.g.
     *
     *   this.onclick = (function() {
     *     console.log('registering');
     *     this.register();
     *   }).bind(this);
     */
    CallExpression: function CallExpression(path$$1) {
      var node = path$$1.node,
          callee = path$$1.node.callee,
          parent = path$$1.parent;


      if (!isMemberExpression(callee)) {
        return;
      }

      var object = callee.object,
          property = callee.property;


      if (!isFunctionExpression(object) || object.id) {
        return;
      }

      if (!isIdentifier(property) || property.name !== 'bind') {
        return;
      }

      if (node.arguments.length !== 1 || !isThisExpression(node.arguments[0])) {
        return;
      }

      var objectPath = path$$1.get('callee').get('object');

      if (referencesArguments(objectPath)) {
        return;
      }

      if (objectPath.node.generator) {
        return;
      }

      // `new` can't be called on arrow functions.
      if (isNewExpression(parent)) {
        path$$1.skip();
        return;
      }

      rewriteBlockArrowFunction(objectPath, module, functions);

      // `() => {}.bind(this)` -> `() => {}bind(this)`
      //          ^

      var _module$tokenIndexRan2 = module.tokenIndexRangeForSourceRange(object.end, property.start),
          start = _module$tokenIndexRan2.start,
          end = _module$tokenIndexRan2.end;

      var tokens = module.tokens;

      for (var i = start; i < end; i++) {
        var token = tokens[i];
        if (token.type.label === '.') {
          editor.remove(token.start, token.end);
        }
      }

      // `() => {}bind(this)` -> `() => {}`
      //          ^^^^^^^^^^
      editor.remove(property.start, node.end);

      replace(node, object);
    }
  };
}

function referencesThisOrArguments(path$$1) {
  var result = false;

  path$$1.scope.traverse(path$$1.node, {
    'FunctionDeclaration|FunctionExpression': function FunctionDeclarationFunctionExpression(fnPath) {
      // Skip nested functions.
      fnPath.skip();
    },
    ThisExpression: function ThisExpression(thisPath) {
      result = true;
      thisPath.stop();
    },
    Identifier: function Identifier(identPath) {
      if (identPath.node.name === 'arguments') {
        result = true;
        identPath.stop();
      }
    }
  });

  return result;
}

function referencesArguments(path$$1) {
  var result = false;

  path$$1.scope.traverse(path$$1.node, {
    Function: function Function(fnPath) {
      // Skip nested functions.
      fnPath.skip();
    },
    Identifier: function Identifier(identPath) {
      if (identPath.node.name === 'arguments') {
        result = true;
        identPath.stop();
      }
    }
  });

  return result;
}

function metadata(module) {
  if (!module.metadata[name]) {
    module.metadata[name] = { functions: [] };
  }
  return module.metadata[name];
}

function rewriteBlocklessArrowFunction(path$$1, module, functions) {
  var node = path$$1.node;

  var _node$body$body2 = slicedToArray(node.body.body, 1),
      statement = _node$body$body2[0];

  functions.push(cleanNode(node));

  var _getFunctionPunctuati = getFunctionPunctuation(node, module),
      fn = _getFunctionPunctuati.fn,
      paramsStart = _getFunctionPunctuati.paramsStart,
      paramsEnd = _getFunctionPunctuati.paramsEnd,
      blockStart = _getFunctionPunctuati.blockStart,
      blockEnd = _getFunctionPunctuati.blockEnd;

  // Only remove parens for a single simple parameter on the same line as the `=>`.


  var paramsNeedParens = node.params.length !== 1 || !isIdentifier(node.params[0]) || node.params[0].loc.end.line !== paramsEnd.loc.start.line;

  var editor = module.magicString;
  if (!paramsNeedParens) {
    // `(a)` -> `a`
    //  ^ ^
    editor.remove(paramsStart.start, paramsStart.end);
    editor.remove(paramsEnd.start, paramsEnd.end);
  }

  // `function() {` -> `() =>`
  editor.remove(fn.start, paramsStart.start);
  editor.overwrite(blockStart.start, blockStart.end, '=>');

  var contentBetweenBlockStartBraceAndReturn = module.source.slice(blockStart.end, statement.start);
  var contentOfReturnArgument = module.sourceOf(statement.argument);

  var shouldCollapseToOneLine =
  // Wouldn't remove anything interesting.
  /^\s*$/.test(contentBetweenBlockStartBraceAndReturn) &&
  // Returned value isn't multi-line.
  /^[^\n\r]*$/.test(contentOfReturnArgument);

  if (shouldCollapseToOneLine) {
    // Removes whitespace between `{` and `return` and `foo;` and `}`.
    //
    //  function() {
    //    return foo;
    //  }
    //
    if (blockStart.end === statement.start) {
      editor.appendLeft(statement.start, ' ');
    } else {
      editor.overwrite(blockStart.end, statement.start, ' ');
    }
    editor.remove(statement.end, blockEnd.end);
  }

  var returnArgumentNeedsParens = isSequenceExpression(statement.argument);

  // `return foo;` -> `foo`
  //  ^^^^^^^   ^
  editor.overwrite(statement.start, statement.argument.start, returnArgumentNeedsParens ? '(' : '');
  if (statement.argument.end === statement.end) {
    editor.appendLeft(statement.end, returnArgumentNeedsParens ? ')' : '');
  } else {
    editor.overwrite(statement.argument.end, statement.end, returnArgumentNeedsParens ? ')' : '');
  }

  // `…}` -> `…`
  editor.remove(blockEnd.start, blockEnd.end);

  node.type = 'ArrowFunctionExpression';
  node.body = statement.argument;
  node.expression = true;

  if (needsParens(path$$1) && !hasParens(path$$1, module)) {
    editor.appendRight(node.start, '(');
    editor.appendLeft(node.end, ')');
  }

  if (bodyNeedsParens(node.body, module.source)) {
    editor.appendRight(node.body.start, '(');
    editor.appendLeft(node.body.end, ')');
  }
}

/**
 * Rewrites a function expression to an arrow function, preserving the block.
 */
function rewriteBlockArrowFunction(path$$1, module, functions) {
  var node = path$$1.node;


  functions.push(cleanNode(node));

  var _getFunctionPunctuati2 = getFunctionPunctuation(node, module),
      fn = _getFunctionPunctuati2.fn,
      paramsStart = _getFunctionPunctuati2.paramsStart,
      paramsEnd = _getFunctionPunctuati2.paramsEnd,
      blockStart = _getFunctionPunctuati2.blockStart;

  var paramsNeedsParens = node.params.length !== 1 || !isIdentifier(node.params[0]);
  var editor = module.magicString;

  if (!paramsNeedsParens) {
    // `(a)` -> `a`
    //  ^ ^
    editor.remove(paramsStart.start, paramsStart.end);
    editor.remove(paramsEnd.start, paramsEnd.end);
  }

  // `function() {` -> `() =>`
  //  ^^^^^^^^   ^         ^^
  editor.remove(fn.start, paramsStart.start);
  editor.appendLeft(blockStart.start, '=> ');

  node.type = 'ArrowFunctionExpression';
}

/**
 * Get the tokens for the relevant function punctuation, i.e.
 *
 *            paramsStart    paramsEnd
 *             fn       |    |
 *              |       |    |
 *              v       v    v
 *   let add = (function(a, b) { <- blockStart
 *     return a + b;
 *   });
 *   ^
 *   |
 *   blockEnd
 */
function getFunctionPunctuation(node, module) {
  var tokens = module.tokensForNode(node);

  var _findToken = findToken('function', tokens, 0),
      functionTokenIndex = _findToken.index,
      fn = _findToken.token;

  var _findToken2 = findToken('(', tokens, functionTokenIndex),
      paramsStartIndex = _findToken2.index,
      paramsStart = _findToken2.token;

  var _findEndParenthesisTo = findEndParenthesisTokenBalanced(tokens, paramsStartIndex),
      paramsEndIndex = _findEndParenthesisTo.index,
      paramsEnd = _findEndParenthesisTo.token;

  var _findToken3 = findToken('{', tokens, paramsEndIndex),
      blockStartIndex = _findToken3.index,
      blockStart = _findToken3.token;

  var _findEndBraceTokenBal = findEndBraceTokenBalanced(tokens, blockStartIndex),
      blockEnd = _findEndBraceTokenBal.token;

  return {
    fn: fn,
    paramsStart: paramsStart,
    paramsEnd: paramsEnd,
    blockStart: blockStart,
    blockEnd: blockEnd
  };
}

function bodyNeedsParens(body, source) {
  return source[body.start] === '{';
}



var functionsArrow = Object.freeze({
	name: name,
	description: description,
	visitor: visitor
});

// FIXME: This is only capable of unindenting one level.
function unindent(magicString) {
  var original = magicString.original;

  var indentString = magicString.getIndentString();

  var atStartOfLine = true;
  for (var i = 0; i < original.length; i++) {
    if (original[i] === '\n' || original[i] === '\r') {
      atStartOfLine = true;
    } else if (atStartOfLine) {
      atStartOfLine = false;
      if (original.slice(i, i + indentString.length) === indentString) {
        magicString.remove(i, i + indentString.length);
      }
    }
  }
}

/**
 * Represents a module binding for either an import or export statement.
 */
var Binding = function () {
  function Binding(localName, exportName) {
    classCallCheck(this, Binding);

    this.localName = localName;
    this.exportName = exportName;
  }

  createClass(Binding, [{
    key: 'isAliased',
    value: function isAliased() {
      return this.localName !== this.exportName;
    }
  }, {
    key: 'isDefaultExport',
    value: function isDefaultExport() {
      return this.exportName === 'default';
    }
  }]);
  return Binding;
}();

/**
 * Builds an export specifier list string for use in an export statement.
 */
var ExportSpecifierListStringBuilder = function () {
  function ExportSpecifierListStringBuilder(bindings) {
    classCallCheck(this, ExportSpecifierListStringBuilder);

    this.bindings = bindings;
  }

  createClass(ExportSpecifierListStringBuilder, [{
    key: 'toString',
    value: function toString() {
      return '{ ' + this.bindings.map(function (binding) {
        if (!binding.isAliased()) {
          return binding.localName;
        } else {
          return binding.localName + ' as ' + binding.exportName;
        }
      }).join(', ') + ' }';
    }
  }], [{
    key: 'build',
    value: function build(bindings) {
      return new ExportSpecifierListStringBuilder(bindings).toString();
    }
  }]);
  return ExportSpecifierListStringBuilder;
}();

/**
 * Builds an import specifier list string for use in an import statement.
 */
var ImportSpecifierListStringBuilder = function () {
  function ImportSpecifierListStringBuilder(bindings) {
    classCallCheck(this, ImportSpecifierListStringBuilder);

    this.bindings = bindings;
  }

  createClass(ImportSpecifierListStringBuilder, [{
    key: 'toString',
    value: function toString() {
      var defaultBinding = void 0;
      var namedBindings = [];

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.bindings[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var binding = _step.value;

          if (binding.isDefaultExport()) {
            defaultBinding = binding;
          } else {
            namedBindings.push(binding);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var result = '';

      var hasNamedBindings = namedBindings.length > 0;
      if (defaultBinding) {
        result += defaultBinding.localName;
        if (hasNamedBindings) {
          result += ', ';
        }
      }

      if (hasNamedBindings) {
        result += '{ ' + namedBindings.map(function (binding) {
          if (!binding.isAliased()) {
            return binding.localName;
          } else {
            return binding.exportName + ' as ' + binding.localName;
          }
        }).join(', ') + ' }';
      }

      return result;
    }
  }], [{
    key: 'build',
    value: function build(bindings) {
      return new ImportSpecifierListStringBuilder(bindings).toString();
    }
  }]);
  return ImportSpecifierListStringBuilder;
}();

function claim(scope) {
  var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'ref';

  if (isUsedName(scope, name)) {
    var suffix = 1;
    var prefix = name;
    do {
      name = prefix + '$' + suffix++;
    } while (isUsedName(scope, name));
  }

  var program = scope.getProgramParent();
  program.references[name] = true;
  program.uids[name] = true;
  return identifier(name);
}

function isDeclaredName(scope, name) {
  return scope.hasBinding(name);
}

function isUsedName(scope, name) {
  return scope.hasBinding(name) || scope.hasGlobal(name)
  // FIXME: Do we want this?
  // scope.hasReference(name)
  ;
}

function hasMemberAccess(assignmentPath) {
  if (isMemberExpression(assignmentPath.node)) {
    return true;
  }
  var found = false;
  assignmentPath.traverse({
    MemberExpression: function MemberExpression(path$$1) {
      found = true;
      path$$1.skip();
    }
  });
  return found;
}

function hasIdentifier(calleePath, names) {
  if (isIdentifier(calleePath.node) && names.indexOf(calleePath.node.name) !== -1) {
    return true;
  }
  var found = false;
  calleePath.traverse({
    Identifier: function Identifier(path$$1) {
      if (names.indexOf(path$$1.node.name) !== -1) {
        found = true;
        path$$1.skip();
      }
    }
  });
  return found;
}

/**
 * Return the position of the first line of code that might affect the global
 * object. Any require calls after this point cannot safely be turned into
 * import statements, since import statements are hoisted.
 */
function getFirstUnsafeLocation(programPath, allowedFunctionIdentifiers) {
  var resultLoc = programPath.node.end;
  programPath.traverse({
    AssignmentExpression: function AssignmentExpression(path$$1) {
      if (hasMemberAccess(path$$1.get('left'))) {
        resultLoc = Math.min(resultLoc, path$$1.node.start);
        path$$1.skip();
      }
    },
    UpdateExpression: function UpdateExpression(path$$1) {
      if (hasMemberAccess(path$$1.get('argument'))) {
        resultLoc = Math.min(resultLoc, path$$1.node.start);
        path$$1.skip();
      }
    },
    CallExpression: function CallExpression(path$$1) {
      if (!hasIdentifier(path$$1.get('callee'), allowedFunctionIdentifiers)) {
        resultLoc = Math.min(resultLoc, path$$1.node.start);
        path$$1.skip();
      }
    },
    ReturnStatement: function ReturnStatement(path$$1) {
      resultLoc = Math.min(resultLoc, path$$1.node.start);
      path$$1.skip();
    },
    ThrowStatement: function ThrowStatement(path$$1) {
      resultLoc = Math.min(resultLoc, path$$1.node.start);
      path$$1.skip();
    }
  });
  return resultLoc;
}

var name$1 = 'modules.commonjs';
var description$1 = 'Transform CommonJS modules into ES6 modules.';

function visitor$1(module) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  metadata$1(module);

  return {
    Program: function Program(path$$1) {
      unwrapIIFE(path$$1, module);
      removeUseStrictDirective(path$$1, module);
      rewriteImportsAndExports(path$$1, module, options.safeFunctionIdentifiers, options.forceDefaultExport);
    },
    ReferencedIdentifier: function ReferencedIdentifier(path$$1) {
      // TODO: Warn about `require`, `module`, and `exports` global references.
      var node = path$$1.node;


      if (node.name === 'require' && !path$$1.scope.hasBinding('require')) {
        var source = extractRequirePathNode(path$$1.parent);

        if (source) {
          module.warn(path$$1.parent, 'unsupported-import', 'Unsupported \'require\' call cannot be transformed into an import');
        }
      } else if (node.name === 'exports') {
        module.warn(node, 'unsupported-export', 'Unsupported export cannot be turned into an \'export\' statement');
      }
    }
  };
}

/**
 * Unwrap an IIFE at program scope if that's the only thing that's there.
 *
 *   (function() {
 *     // All program body here.
 *   })();
 */
function unwrapIIFE(path$$1, module) {
  var node = path$$1.node;

  var iife = extractModuleIIFE(node);

  if (!iife) {
    return;
  }

  var _node$body = slicedToArray(node.body, 1),
      statement = _node$body[0];

  var body = iife.body.body;


  node.body = body;
  metadata$1(module).unwrapped = cleanNode(iife);

  var tokens = module.tokensForNode(iife);
  var iifeHeaderEnd = body[0].start;

  var _findToken = findToken('{', tokens),
      iifeBlockStartIndex = _findToken.index,
      iifeBlockStart = _findToken.token;

  for (var p = iifeBlockStart.end; p < iifeHeaderEnd; p++) {
    if (module.source.charAt(p) === '\n') {
      iifeHeaderEnd = p + 1;
      break;
    }
  }

  var iifeFooterStart = body[body.length - 1].end;

  var _findEndTokenBalanced = findEndTokenBalanced('{', '}', tokens, iifeBlockStartIndex),
      iifeBlockEnd = _findEndTokenBalanced.token;

  for (var _p = iifeBlockEnd.start; _p > iifeFooterStart; _p--) {
    if (module.source.charAt(_p) === '\n') {
      if (module.source.charAt(_p) === '\r') {
        _p--;
      }
      iifeFooterStart = _p;
      break;
    }
  }

  // `(function() {\n  foo();\n})();` -> `foo();`
  //  ^^^^^^^^^^^^^^^^^      ^^^^^^^
  module.magicString.remove(statement.start, iifeHeaderEnd);
  module.magicString.remove(iifeFooterStart, statement.end);
  unindent(module.magicString);
}

/**
 * Remove a 'use strict' directive in `path`'s body.
 */
function removeUseStrictDirective(path$$1, module) {
  var directives = path$$1.node.directives;

  for (var i = 0; i < directives.length; i++) {
    var directive = directives[i];

    if (directive.value.value === 'use strict') {
      var start = directive.start,
          end = directive.end;

      // Eat any trailing newlines.

      while (module.source.charAt(end) === '\n') {
        end++;
      }

      module.magicString.remove(start, end);
      directives.splice(i, 1);
      metadata$1(module).directives.push(cleanNode(directive));
    }
  }
}

/**
 * Re-write requires as imports/exports and exports sets as export statements.
 */
function rewriteImportsAndExports(path$$1, module) {
  var safeFunctionIdentifiers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var forceDefaultExport = arguments[3];

  var body = path$$1.get('body');

  if (!Array.isArray(body)) {
    throw new Error('expected body paths from program node, got: ' + body);
  }

  if (forceDefaultExport) {
    rewriteStatementsAsDefaultExport(path$$1, module);
  } else {
    body.forEach(function (statement) {
      return rewriteAsExport(statement, module, forceDefaultExport);
    });
  }

  var collectedDefaultImportNames = [];
  var firstUnsafeLocation = getFirstUnsafeLocation(path$$1, ['require'].concat(toConsumableArray(safeFunctionIdentifiers)));
  body.forEach(function (statement) {
    return rewriteAsImport(statement, module, firstUnsafeLocation, collectedDefaultImportNames);
  });
  removeDefaultAccesses(path$$1, module, collectedDefaultImportNames);
}

/**
 * Rewrites the exports for a file, intentionally converting to a default export
 * with the same value as the previous module.exports.
 */
function rewriteStatementsAsDefaultExport(programPath, module) {
  var exportPaths = [];
  programPath.traverse({
    'MemberExpression|Identifier|ThisExpression': function MemberExpressionIdentifierThisExpression(path$$1) {
      if (isExportsObject(path$$1)) {
        exportPaths.push(path$$1);
        path$$1.skip();
      }
    }
  });

  if (exportPaths.length === 0) {
    return;
  }

  // Turn a unique `module.exports` line into a single `export default` statement.
  if (exportPaths.length === 1) {
    var exportPath = exportPaths[0];
    var enclosingStatement = getEnclosingStatement(exportPath);
    if (isExpressionStatement(enclosingStatement.node) && isAssignmentExpression(enclosingStatement.node.expression) && enclosingStatement.node.expression.left === exportPath.node) {
      rewriteAssignmentToDefaultExport(enclosingStatement, module);
      return;
    }
  }

  var exportsIdentifier = claim(programPath.scope, 'defaultExport');
  var exportsVarName = exportsIdentifier.name;
  var firstStatement = getEnclosingStatement(exportPaths[0]);
  var lastStatement = getEnclosingStatement(exportPaths[exportPaths.length - 1]);

  module.magicString.appendLeft(firstStatement.node.start, 'let ' + exportsVarName + ' = {};\n');
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = exportPaths[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _exportPath = _step.value;

      module.magicString.overwrite(_exportPath.node.start, _exportPath.node.end, exportsVarName);
      _exportPath.replaceWith(exportsIdentifier);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  module.magicString.appendLeft(lastStatement.node.end, '\nexport default ' + exportsVarName + ';');
}

function getEnclosingStatement(path$$1) {
  var resultPath = path$$1;
  while (!isProgram(resultPath.parentPath.node)) {
    resultPath = resultPath.parentPath;
  }
  return resultPath;
}

function rewriteAsExport(path$$1, module) {
  var node = path$$1.node;


  if (!isExpressionStatement(node)) {
    return false;
  }

  var expression = node.expression;


  if (!isAssignmentExpression(expression)) {
    return false;
  }

  var left = expression.left,
      right = expression.right;


  if (isExportsObject(path$$1.get('expression.left'))) {
    return rewriteSingleExportAsDefaultExport(path$$1, module);
  } else if (isMemberExpression(left) && !left.computed) {
    if (!isExportsObject(path$$1.get('expression.left.object'))) {
      return false;
    }

    if (isFunctionExpression(right)) {
      return rewriteNamedFunctionExpressionExport(path$$1, module);
    } else if (isIdentifier(right)) {
      return rewriteNamedIdentifierExport(path$$1, module);
    } else {
      return rewriteNamedValueExport(path$$1, module);
    }
  } else {
    return false;
  }
}

function isExportsObject(path$$1) {
  var node = path$$1.node;


  if (isMemberExpression(node)) {
    return !path$$1.scope.hasBinding('module') && isIdentifier(node.object, { name: 'module' }) && isIdentifier(node.property, { name: 'exports' });
  } else if (isIdentifier(node, { name: 'exports' })) {
    return !path$$1.scope.hasBinding('exports');
  } else {
    return isTopLevelThis(path$$1);
  }
}

function isTopLevelThis(path$$1) {
  if (!isThisExpression(path$$1)) {
    return false;
  }
  var ancestor = path$$1;
  while (!isProgram(ancestor.node)) {
    if (isFunction(ancestor.node) && !isArrowFunctionExpression(ancestor.node)) {
      return false;
    }
    ancestor = ancestor.parentPath;
  }
  return true;
}

function isSimpleObjectExpression(node) {
  if (!isObjectExpression(node)) {
    return false;
  }
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = node.properties[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var property = _step2.value;

      if (!isObjectProperty(property) || !isIdentifier(property.key) || !isIdentifier(property.value)) {
        return false;
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return true;
}

function rewriteSingleExportAsDefaultExport(path$$1, module) {
  var node = path$$1.node,
      right = path$$1.node.expression.right;


  if (isSimpleObjectExpression(right)) {
    var _bindings = [];

    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = right.properties[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var _step3$value = _step3.value,
            key = _step3$value.key,
            value = _step3$value.value;

        _bindings.push(new Binding(value.name, key.name));
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3.return) {
          _iterator3.return();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    metadata$1(module).exports.push({
      type: 'named-export',
      bindings: _bindings,
      node: cleanNode(node)
    });

    module.magicString.overwrite(node.start, node.end, 'export ' + ExportSpecifierListStringBuilder.build(_bindings) + ';');

    path$$1.replaceWith(exportNamedDeclaration(null, _bindings.map(function (binding) {
      return exportSpecifier(identifier(binding.localName), identifier(binding.exportName));
    }), null));
  } else {
    var _pathNode = extractRequirePathNode(right);

    if (_pathNode) {
      module.magicString.overwrite(node.expression.start, node.expression.end, 'export * from ' + module.source.slice(_pathNode.start, _pathNode.end));

      metadata$1(module).exports.push({
        type: 'namespace-export',
        bindings: [],
        node: cleanNode(node)
      });

      path$$1.replaceWith(exportAllDeclaration(_pathNode));
    } else {
      rewriteAssignmentToDefaultExport(path$$1, module);
    }
  }

  return true;
}

function getAssignmentEqualsEnd(node, module) {
  var equalsToken = findToken('=', module.tokensForNode(node));
  var equalsEnd = equalsToken.token.end;
  if (module.magicString.slice(equalsEnd, equalsEnd + 1) === ' ') {
    equalsEnd++;
  }
  return equalsEnd;
}

function rewriteAssignmentToDefaultExport(path$$1, module) {
  var node = path$$1.node;
  var right = path$$1.node.expression.right;
  metadata$1(module).exports.push({ type: 'default-export', node: cleanNode(node) });

  module.magicString.overwrite(path$$1.node.start, getAssignmentEqualsEnd(node, module), 'export default ');

  path$$1.replaceWith(exportDefaultDeclaration(right));
}

function rewriteNamedFunctionExpressionExport(path$$1, module) {
  var node = path$$1.node,
      _path$node$expression = path$$1.node.expression,
      exportName = _path$node$expression.left.property.name,
      right = _path$node$expression.right,
      id = _path$node$expression.right.id;


  var fnBinding = id ? id.name : null;
  var localId = claim(path$$1.scope, fnBinding || exportName);
  var localName = localId.name;

  metadata$1(module).exports.push({
    type: 'named-export',
    bindings: [{
      exportName: exportName,
      localName: localName
    }],
    node: cleanNode(node)
  });

  if (localName === exportName) {
    // `exports.foo = function foo() {}` → `export function foo() {}`
    //  ^^^^^^^^^^^^^^                      ^^^^^^^
    module.magicString.overwrite(node.start, getAssignmentEqualsEnd(node, module), 'export ');

    if (!id) {
      module.magicString.appendLeft(right.start + 'function'.length, ' ' + localName);
      right.id = identifier(exportName);
    }

    removeTrailingSemicolon(node, module);

    right.type = 'FunctionDeclaration';
    right.expression = false;
    right.id = identifier(exportName);
    delete right.start;
    delete right.end;

    path$$1.replaceWith(exportNamedDeclaration(right, [], null));
  } else {
    var declaration = right;
    var isFunctionDeclaration = true;

    if (!id) {
      module.magicString.remove(node.start, right.start);
      module.magicString.appendLeft(right.start + 'function'.length, ' ' + localName);
      right.type = 'FunctionDeclaration';
      right.id = localId;
    } else if (fnBinding === localName) {
      right.type = 'FunctionDeclaration';
      module.magicString.remove(node.start, right.start);
    } else {
      isFunctionDeclaration = false;
      module.magicString.overwrite(node.start, getAssignmentEqualsEnd(node, module), 'let ' + localName + ' = ');
      declaration = variableDeclaration('let', [variableDeclarator(localId, right)]);
    }

    if (isFunctionDeclaration) {
      removeTrailingSemicolon(node, module);
    }

    module.magicString.appendLeft(node.end, '\nexport { ' + localName + ' as ' + exportName + ' };');

    path$$1.replaceWithMultiple([declaration, exportNamedDeclaration(null, [exportSpecifier(localId, identifier(exportName))])]);
  }
}

function removeTrailingSemicolon(node, module) {
  var lastCharacterPosition = node.end - 1;

  if (module.source.charAt(lastCharacterPosition) === ';') {
    module.magicString.remove(lastCharacterPosition, node.end);
  }
}

function rewriteNamedIdentifierExport(path$$1, module) {
  var node = path$$1.node,
      _path$node$expression2 = path$$1.node.expression,
      property = _path$node$expression2.left.property,
      right = _path$node$expression2.right;


  var replacements = void 0;
  var localBinding = void 0;

  if (isDeclaredName(path$$1.scope, right.name)) {
    localBinding = right.name;

    if (right.name === property.name) {
      module.magicString.overwrite(node.start, node.end, 'export { ' + right.name + ' };');
    } else {
      module.magicString.overwrite(node.start, node.end, 'export { ' + right.name + ' as ' + property.name + ' };');
    }

    replacements = [exportNamedDeclaration(null, [exportSpecifier(right, property)], null)];
  } else {
    localBinding = claim(path$$1.scope, property.name).name;

    if (localBinding === property.name) {
      module.magicString.overwrite(node.start, getAssignmentEqualsEnd(node, module), 'export let ' + localBinding + ' = ');
      replacements = [exportNamedDeclaration(variableDeclaration('let', [variableDeclarator(identifier(localBinding), right)]), [], null)];
    } else {
      module.magicString.overwrite(node.start, getAssignmentEqualsEnd(node, module), 'let ' + localBinding + ' = ');
      module.magicString.appendLeft(node.end, '\nexport { ' + localBinding + ' as ' + property.name + ' };');
      replacements = [variableDeclaration('let', [variableDeclarator(identifier(localBinding), right)]), exportNamedDeclaration(null, [exportSpecifier(identifier(localBinding), property)], null)];
    }
  }

  metadata$1(module).exports.push({
    type: 'named-export',
    bindings: [{
      exportName: property.name,
      localName: localBinding
    }],
    node: cleanNode(node)
  });

  path$$1.replaceWithMultiple(replacements);

  return true;
}

function rewriteNamedValueExport(path$$1, module) {
  var node = path$$1.node,
      _path$node$expression3 = path$$1.node.expression,
      property = _path$node$expression3.left.property,
      right = _path$node$expression3.right;

  var localBinding = claim(path$$1.scope, property.name).name;

  metadata$1(module).exports.push({
    type: 'named-export',
    bindings: [{
      exportName: property.name,
      localName: localBinding
    }],
    node: cleanNode(node)
  });

  if (localBinding === property.name) {
    // `exports.foo = 99;` → `export let foo = 99;`
    //  ^^^^^^^^              ^^^^^^^^^^^
    module.magicString.overwrite(node.start, property.start, 'export let ');

    path$$1.replaceWith(exportNamedDeclaration(variableDeclaration('let', [variableDeclarator(identifier(property.name), right)]), [], null));
  } else {
    // `exports.foo = 99;` → `let foo$1 = 99;`
    //  ^^^^^^^^^^^^^^        ^^^^^^^^^^^^
    module.magicString.overwrite(node.start, getAssignmentEqualsEnd(node, module), 'let ' + localBinding + ' = ');

    var nodeIndex = path$$1.parent.body.indexOf(node);

    if (nodeIndex < 0) {
      throw new Error('could not locate ' + node.type + ' at ' + node.line + ':' + node.column + ' in its parent block');
    }

    var nextStatement = path$$1.parent.body[nodeIndex + 1];

    // `export { foo$1 as foo };`
    var exportStatement = 'export { ' + localBinding + ' as ' + property.name + ' };';

    if (nextStatement) {
      // Insert before the next statement…
      module.magicString.appendLeft(nextStatement.start, exportStatement + '\n');
    } else {
      // …or after the last one of the program.
      module.magicString.appendLeft(node.end, '\n' + exportStatement);
    }

    path$$1.replaceWithMultiple([variableDeclaration('let', [variableDeclarator(identifier(localBinding), right)]), exportNamedDeclaration(null, [exportSpecifier(identifier(localBinding), identifier(property.name))], null)]);
  }

  return true;
}

/**
 * Rewrite this potential import statement, considering various import styles.
 * Any new default import names are added to collectedDefaultImportNames.
 */
function rewriteAsImport(path$$1, module, firstUnsafeLocation, collectedDefaultImportNames) {
  if (isDeclaredName(path$$1.scope, 'require')) {
    return false;
  }

  if (path$$1.node && path$$1.node.end > firstUnsafeLocation) {
    return false;
  }

  return rewriteSingleExportRequire(path$$1, module, collectedDefaultImportNames) || rewriteNamedExportRequire(path$$1, module) || rewriteDeconstructedImportRequire(path$$1, module) || rewriteSideEffectRequire(path$$1, module);
}

/**
 * Convert
 * let a = require('b');
 * to
 * import a from 'b';
 *
 * Any imported names are added to the collectedDefaultImportNames parameter.
 */
function rewriteSingleExportRequire(path$$1, module, collectedDefaultImportNames) {
  var node = path$$1.node;


  if (!isVariableDeclaration(node)) {
    return false;
  }

  var declarations = node.declarations;

  var extractableDeclarations = [];

  declarations.forEach(function (declaration) {
    var id = declaration.id,
        init = declaration.init;


    if (!isIdentifier(id)) {
      return;
    }

    var pathNode = extractRequirePathNode(init);

    if (!pathNode) {
      return;
    }

    extractableDeclarations.push({
      declaration: declaration, id: id, pathNode: pathNode
    });
  });

  if (declarations.length === 0) {
    return false;
  }

  if (declarations.length !== extractableDeclarations.length) {
    // TODO: We have to replace only part of it.
    return false;
  }

  rewriteRequireAsImports('default-import', path$$1, module, extractableDeclarations.map(function (_ref) {
    var id = _ref.id,
        pathNode = _ref.pathNode;
    return {
      bindings: [new Binding(id.name, 'default')],
      pathNode: pathNode
    };
  }));

  path$$1.replaceWithMultiple(extractableDeclarations.map(function (_ref2) {
    var id = _ref2.id,
        pathNode = _ref2.pathNode;
    return importDeclaration([importDefaultSpecifier(id)], pathNode);
  }));

  collectedDefaultImportNames.push.apply(collectedDefaultImportNames, toConsumableArray(extractableDeclarations.map(function (d) {
    return d.id.name;
  })));
  return true;
}

/**
 * Convert
 * let a = require('b').c;
 * to
 * import { c as a } from 'b';
 */
function rewriteNamedExportRequire(path$$1, module) {
  var declaration = extractSingleDeclaration(path$$1.node);

  if (!declaration) {
    return false;
  }

  var id = declaration.id,
      init = declaration.init;


  if (!isIdentifier(id) || !init || !isMemberExpression(init) || init.computed) {
    return false;
  }

  var pathNode = extractRequirePathNode(init.object);

  if (!pathNode) {
    return false;
  }

  rewriteRequireAsImport('named-import', path$$1, module, [new Binding(id.name, init.property.name)], pathNode);

  path$$1.replaceWith(importDeclaration([importSpecifier(id, init.property)], pathNode));

  return true;
}

/**
 * Convert
 * let { a } = require('b');
 * to
 * import { a } from 'b';
 */
function rewriteDeconstructedImportRequire(path$$1, module) {
  var declaration = extractSingleDeclaration(path$$1.node);

  if (!declaration) {
    return false;
  }

  var id = declaration.id,
      init = declaration.init;


  if (!isObjectPattern(id)) {
    return false;
  }

  var bindings = [];

  var _iteratorNormalCompletion4 = true;
  var _didIteratorError4 = false;
  var _iteratorError4 = undefined;

  try {
    for (var _iterator4 = id.properties[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
      var _step4$value = _step4.value,
          key = _step4$value.key,
          value = _step4$value.value;

      if (!isIdentifier(value)) {
        return false;
      }
      bindings.push(new Binding(value.name, key.name));
    }
  } catch (err) {
    _didIteratorError4 = true;
    _iteratorError4 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion4 && _iterator4.return) {
        _iterator4.return();
      }
    } finally {
      if (_didIteratorError4) {
        throw _iteratorError4;
      }
    }
  }

  var pathNode = extractRequirePathNode(init);

  if (!pathNode) {
    return false;
  }

  rewriteRequireAsImport('named-import', path$$1, module, bindings, pathNode);

  path$$1.replaceWith(importDeclaration(bindings.map(function (binding) {
    return importSpecifier(identifier(binding.localName), identifier(binding.exportName));
  }), pathNode));

  return true;
}

/**
 * Convert
 * require('a');
 * to
 * import 'a';
 */
function rewriteSideEffectRequire(path$$1, module) {
  var node = path$$1.node;


  if (!isExpressionStatement(node)) {
    return false;
  }

  var pathNode = extractRequirePathNode(node.expression);

  if (!pathNode) {
    return false;
  }

  rewriteRequireAsImport('bare-import', path$$1, module, [], pathNode);

  path$$1.replaceWith(importDeclaration([], pathNode));

  return true;
}

function rewriteRequireAsImport(type, path$$1, module, bindings, pathNode) {
  rewriteRequireAsImports(type, path$$1, module, [{ bindings: bindings, pathNode: pathNode }]);
}

function rewriteRequireAsImports(type, path$$1, module, imports) {
  var node = path$$1.node;

  var importStatements = [];

  imports.forEach(function (_ref3) {
    var bindings = _ref3.bindings,
        pathNode = _ref3.pathNode;

    metadata$1(module).imports.push({
      type: type,
      node: cleanNode(node),
      bindings: bindings,
      path: pathNode.value
    });

    var pathString = module.source.slice(pathNode.start, pathNode.end);

    if (bindings.length === 0) {
      importStatements.push('import ' + pathString + ';');
    } else {
      importStatements.push('import ' + ImportSpecifierListStringBuilder.build(bindings) + ' from ' + pathString + ';');
    }
  });

  module.magicString.overwrite(node.start, node.end, importStatements.join('\n'));
}

/**
 * Remove `.default` accesses on names that are known to be default imports.
 * For example, if `let a = require('a');` became `import a from 'a';`, then
 * any usage of `a.default` should change to just `a`.
 *
 * Note that this isn't 100% correct, and being fully correct here is
 * undecidable, but it seems good enough for real-world cases.
 */
function removeDefaultAccesses(programPath, module, defaultImportNames) {
  programPath.traverse({
    MemberExpression: function MemberExpression(path$$1) {
      var _path$node = path$$1.node,
          object = _path$node.object,
          property = _path$node.property,
          computed = _path$node.computed;

      if (computed) {
        return;
      }
      if (!computed && isIdentifier(object) && defaultImportNames.indexOf(object.name) !== -1 && isIdentifier(property) && property.name === 'default') {
        var dotToken = findToken('.', module.tokensInRange(object.end, path$$1.node.end));
        module.magicString.remove(dotToken.token.start, property.end);
      }
    }
  });
}

function metadata$1(module) {
  if (!module.metadata[name$1]) {
    module.metadata[name$1] = {
      imports: [],
      exports: [],
      directives: []
    };
  }
  return module.metadata[name$1];
}

function extractSingleDeclaration(node) {
  if (!isVariableDeclaration(node)) {
    return null;
  }

  if (node.declarations.length !== 1) {
    return null;
  }

  return node.declarations[0];
}

function extractRequirePathNode(node) {
  if (!node || !isCallExpression(node)) {
    return null;
  }

  if (!isIdentifier(node.callee, { name: 'require' })) {
    return null;
  }

  if (node.arguments.length !== 1) {
    return null;
  }

  var arg = node.arguments[0];

  if (!isStringLiteral(arg)) {
    return null;
  }

  return arg;
}

/**
 * @private
 */
function extractModuleIIFE(node) {
  if (!isProgram(node)) {
    return null;
  }

  if (node.body.length !== 1) {
    return null;
  }

  var _node$body2 = slicedToArray(node.body, 1),
      statement = _node$body2[0];

  if (!isExpressionStatement(statement)) {
    return null;
  }

  var call = statement.expression;


  if (isUnaryExpression(call) && call.operator === 'void') {
    // e.g. `void function(){}();`
    call = call.argument;
  }

  if (!isCallExpression(call)) {
    return null;
  }

  var _call = call,
      callee = _call.callee,
      args = _call.arguments;


  var iife = void 0;

  if (isFunctionExpression(callee)) {
    // e.g. `(function() {})();`
    if (args.length !== 0) {
      return null;
    }

    iife = callee;
  } else if (isMemberExpression(callee)) {
    // e.g. `(function() {}).call(this);`
    var object = callee.object,
        property = callee.property,
        computed = callee.computed;


    if (computed || !isFunctionExpression(object)) {
      return null;
    }

    if (!isIdentifier(property, { name: 'call' })) {
      return null;
    }

    if (args.length !== 1 || !isThisExpression(args[0])) {
      return null;
    }

    iife = object;
  } else {
    return null;
  }

  if (iife.id || iife.params.length > 0 || iife.generator) {
    return null;
  }

  return iife;
}



var modulesCommonjs = Object.freeze({
	name: name$1,
	description: description$1,
	visitor: visitor$1
});

/**
 * Determines the most restrictive declaration kind for a variable declaration.
 * `const` is preferred, followed by `let` if one or more bindings are
 * reassigned, then `var` if block scoping cannot be used.
 */
function mostRestrictiveKindForDeclaration(path$$1) {
  var ids = path$$1.getBindingIdentifiers();
  var scope = path$$1.scope;

  var isConst = path$$1.node.declarations.every(function (declaration) {
    return declaration.init;
  });

  if (isSwitchCase(path$$1.parent)) {
    return 'var';
  }

  for (var id in ids) {
    var binding = scope.getBinding(id);

    // Does this binding disqualify block scoping for this declaration entirely?
    if (!bindingCouldBeBlockScope(binding)) {
      return 'var';
    }

    // Is this binding reassigned?
    if (isConst && !binding.constant) {
      isConst = false;
    }
  }

  return isConst ? 'const' : 'let';
}

/**
 * Does this binding meet the requirements for block scoping?
 */
function bindingCouldBeBlockScope(binding) {
  // Are there duplicate declarations?
  if (binding.constantViolations.some(function (path$$1) {
    return isVariableDeclarator(path$$1.node);
  })) {
    return false;
  }

  var definition = binding.path;
  var definitionBlockParent = definition.findParent(function (path$$1) {
    return path$$1.isBlockParent();
  });

  if ([].concat(toConsumableArray(binding.referencePaths), toConsumableArray(binding.constantViolations)).some(function (reference) {
    return (
      // Does this reference come before the definition?
      reference.node.start < definition.node.start ||
      // Does this reference exist outside the declaration block?
      !reference.isDescendant(definitionBlockParent) ||
      // Is this reference the initial binding value?
      reference === binding.path.get('init') ||
      // Is this reference inside the initial binding value?
      reference.isDescendant(binding.path.get('init'))
    );
  })) {
    return false;
  }

  var functionParent = definition.getFunctionParent();
  var loopParent = definition.findParent(function (path$$1) {
    return path$$1.isLoop();
  });

  // Is this declaration within a loop in the current function scope?
  if (loopParent !== null && loopParent.isDescendant(functionParent)) {
    // Is any reference within a closure?
    if (binding.referencePaths.some(function (reference) {
      return reference.getFunctionParent() !== functionParent;
    })) {
      return false;
    }

    if (!isBindingAssignedBeforeUse(binding)) {
      return false;
    }
  }

  return true;
}

/**
 * Return true if we can statically determine that this variable always assigned
 * a value in its block before it is used. In other words, check if we can be
 * sure that the variable will never hold a value from a previous loop
 * iteration.
 */
function isBindingAssignedBeforeUse(binding) {
  // Loop assignees are always initialized before use.
  var loopParent = binding.path.findParent(function (path$$1) {
    return path$$1.isLoop();
  });
  if (loopParent !== null) {
    if (loopParent.isForAwaitStatement() || loopParent.isForInStatement() || loopParent.isForOfStatement()) {
      if (binding.path.isDescendant(loopParent.get('left'))) {
        return true;
      }
    }
  }

  // Variables with an explicit init are always assigned before use.
  if (binding.path.isVariableDeclarator() && binding.path.node.init !== null) {
    return true;
  }

  // Find simple top-level assignments that occur before all usages. This could
  // theoretically be extended to do more advanced static analysis, e.g.
  // traversing into conditional blocks and ternary expressions to see if all
  // code paths assign to this variable, but this should get the common case.
  var blockParent = binding.path.findParent(function (path$$1) {
    return path$$1.isBlockParent();
  });
  var earliestUsage = Math.min.apply(Math, toConsumableArray(binding.referencePaths.map(function (reference) {
    return reference.node.start;
  })));
  if (binding.constantViolations.some(function (path$$1) {
    return path$$1.node.end < earliestUsage && path$$1.isAssignmentExpression() && path$$1.parentPath.isExpressionStatement() && path$$1.parentPath.parentPath === blockParent;
  })) {
    return true;
  }

  return false;
}

var name$2 = 'declarations.block-scope';
var description$2 = 'Transform `var` into `let` and `const` as appropriate.';

function visitor$2(module) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var _metadata = metadata$2(module),
      declarations = _metadata.declarations;

  return {
    VariableDeclaration: function VariableDeclaration(path$$1) {
      var node = path$$1.node;


      if (node.kind !== 'var') {
        return;
      }

      var kind = mostRestrictiveKindForDeclaration(path$$1);

      if (kind !== 'var') {
        if (kind === 'const' && !constAllowed(path$$1, options)) {
          kind = 'let';
        }
        module.magicString.overwrite(node.start, node.start + 'var'.length, kind);
        declarations.push(cleanNode(node));
        node.kind = kind;
      } else {
        module.warn(node, 'unsupported-declaration', '\'var\' declaration cannot be converted to block scope');
      }
    }
  };
}

/**
 * Delegates to user-supplied options to determine whether `let` is allowed.
 */
function constAllowed(path$$1, options) {
  var disableConst = options.disableConst;

  if (typeof disableConst === 'function') {
    return !disableConst(path$$1);
  } else {
    return !disableConst;
  }
}

function metadata$2(module) {
  if (!module.metadata[name$2]) {
    module.metadata[name$2] = { declarations: [] };
  }
  return module.metadata[name$2];
}

var declarationsBlockScope = Object.freeze({
	name: name$2,
	description: description$2,
	visitor: visitor$2
});

var name$3 = 'objects.destructuring';
var description$3 = 'Transform some declarations and assignments to the more compact destructuring form.';

function visitor$3(module) {
  var meta = metadata$3(module);

  return {
    VariableDeclaration: function VariableDeclaration(path$$1) {
      var node = path$$1.node;


      for (var index = 0; index < node.declarations.length; index++) {
        var elements = extractSequentialDestructurableElements(module, node.declarations, index);
        rewriteDestructurableElements(module, elements);

        if (elements.length !== 0) {
          // Add information about the transformation.
          meta.push({
            ids: elements.map(function (_ref) {
              var id = _ref.id;
              return cleanNode(id);
            }),
            inits: elements.map(function (_ref2) {
              var init = _ref2.init;
              return cleanNode(init);
            })
          });

          // Mutate the AST to reflect the new reality.
          node.declarations.splice(index, elements.length, variableDeclarator(objectPattern(elements.map(function (declarator) {
            return objectProperty(declarator.id, declarator.id, false, true);
          })), elements[0].init.object));
        }
      }
    },
    AssignmentExpression: function AssignmentExpression(path$$1) {
      if (!isExpressionStatement(path$$1.parent)) {
        return;
      }

      var node = path$$1.node;

      var assignments = extractSequentialDestructurableElements(module, [node]);

      if (assignments.length === 0) {
        return;
      }

      // `a = obj.a;` -> `(a = obj.a);`
      //                  ^         ^
      module.magicString.appendLeft(assignments[0].start, '(');
      module.magicString.appendRight(assignments[assignments.length - 1].end, ')');

      rewriteDestructurableElements(module, assignments);

      // Add information about the transformation.
      meta.push({
        ids: assignments.map(function (assignment) {
          return cleanNode(assignment.left);
        }),
        inits: assignments.map(function (assignment) {
          return cleanNode(assignment.right);
        })
      });

      path$$1.replaceWith(assignmentExpression('=', objectPattern(assignments.map(function (assignment) {
        return objectProperty(identifier(assignment.left.name), identifier(assignment.left.name), false, true);
      })), node.right.object));
    },
    SequenceExpression: function SequenceExpression(path$$1) {
      var expressions = path$$1.node.expressions;


      for (var index = 0; index < expressions.length; index++) {
        var assignments = extractSequentialDestructurableElements(module, expressions, index);

        if (assignments.length > 0 && index === 0) {
          // `a = obj.a;` -> `(a = obj.a);`
          module.magicString.appendLeft(assignments[0].start, '(');
          module.magicString.appendRight(assignments[assignments.length - 1].end, ')');
        }

        if (assignments.length > 0) {
          rewriteDestructurableElements(module, assignments);

          meta.push({
            ids: assignments.map(function (assignment) {
              return cleanNode(assignment.left);
            }),
            inits: assignments.map(function (assignment) {
              return cleanNode(assignment.right);
            })
          });

          expressions.splice(index, assignments.length, assignmentExpression('=', objectPattern(assignments.map(function (_ref3) {
            var left = _ref3.left;
            return objectProperty(left, left, false, true);
          })), assignments[0].right.object));
        }
      }

      if (expressions.length === 1) {
        path$$1.replaceWith(expressions[0]);
      }
    }
  };
}

function extractSequentialDestructurableElements(module, elements) {
  var start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

  var result = [];
  var objectSource = null;

  for (var i = start; i < elements.length; i++) {
    var element = elements[i];

    var _ref4 = leftRightOfAssignment(element) || {},
        _left = _ref4.left,
        _right = _ref4.right;

    if (!isIdentifier(_left)) {
      break;
    }

    if (!isMemberExpression(_right)) {
      break;
    }

    if (_right.computed) {
      break;
    }

    if (_left.name !== _right.property.name) {
      break;
    }

    var thisObjectSource = module.sourceOf(_right.object);

    if (!objectSource) {
      objectSource = thisObjectSource;
    } else if (objectSource !== thisObjectSource) {
      break;
    }

    result.push(element);

    if (!isSafeToConsolidate(_right.object)) {
      break;
    }
  }

  return result;
}

function rewriteDestructurableElements(module, elements) {
  if (elements.length === 0) {
    return;
  }

  var firstElement = elements[0];

  // `const a = obj.a, b = obj.b;` -> `const { a = obj.a, b = obj.b;`
  //                                         ^^
  module.magicString.appendLeft(leftRightOfAssignment(firstElement).left.start, '{ ');

  for (var i = 0; i < elements.length - 1; i++) {
    var _leftRightOfAssignmen = leftRightOfAssignment(elements[i]),
        _left2 = _leftRightOfAssignmen.left,
        _right2 = _leftRightOfAssignmen.right;
    // `const { a = obj.a, b = obj.b;` -> `const { a, b = obj.b;`
    //           ^^^^^^^^


    module.magicString.remove(_left2.end, _right2.end);
  }

  var lastElement = elements[elements.length - 1];

  var _leftRightOfAssignmen2 = leftRightOfAssignment(lastElement),
      lastLeft = _leftRightOfAssignmen2.left,
      lastRight = _leftRightOfAssignmen2.right;

  // `const { a, b = obj.b;` -> `const { a, b } = obj.b;`
  //                                         ^^


  module.magicString.appendRight(lastLeft.end, ' }');

  var dotToken = getDotToken(module, lastRight);
  // `const { a, b } = obj.b;` -> `const { a, b } = obj;`
  //                      ^^
  module.magicString.remove(dotToken.start, lastRight.end);
}

function getDotToken(module, memberAccessExpression) {
  var intermediateTokens = module.tokensInRange(memberAccessExpression.object.end, memberAccessExpression.property.start);
  var dotTokenIndex = intermediateTokens.length - 1;
  while (dotTokenIndex >= 0 && intermediateTokens[dotTokenIndex].type.label !== '.') {
    dotTokenIndex -= 1;
  }
  if (dotTokenIndex < 0) {
    throw new Error('Expected to find a dot token in a member access expression.');
  }
  return intermediateTokens[dotTokenIndex];
}

function metadata$3(module) {
  if (!module.metadata[name$3]) {
    module.metadata[name$3] = [];
  }
  return module.metadata[name$3];
}

function leftRightOfAssignment(node) {
  if (isVariableDeclarator(node)) {
    return { left: node.id, right: node.init };
  } else if (isAssignmentExpression(node) && node.operator === '=') {
    return { left: node.left, right: node.right };
  } else {
    return null;
  }
}

function isSafeToConsolidate(node) {
  return isIdentifier(node);
}

var objectsDestructuring = Object.freeze({
	name: name$3,
	description: description$3,
	visitor: visitor$3
});

/**
 * Change the escape characters to convert the given string contents from one
 * quote style to another.
 */
function convertStringEscaping(fromQuote, toQuote, string) {
  if (fromQuote === toQuote) {
    return string;
  }
  var result = '';
  for (var i = 0; i < string.length; i++) {
    // We always start in an unescaped position, and advance forward if we see
    // an escape.
    if (string[i] === '\\') {
      if (string[i + 1] === fromQuote) {
        // No need to escape anymore.
        result += string[i + 1];
        i++;
      } else {
        // Copy both characters (or just one if we're at the end).
        result += string.slice(i, i + 2);
        i++;
      }
    } else if (string[i] === toQuote) {
      result += '\\' + string[i];
    } else if (string.slice(i, i + 2) === '${' && toQuote === '`') {
      result += '\\' + string[i];
    } else {
      result += string[i];
    }
  }
  return result;
}

var name$4 = 'strings.template';
var description$4 = 'Transforms manual string concatenation into template strings.';

function visitor$4(module) {
  var meta = metadata$4(module);

  return {
    BinaryExpression: function BinaryExpression(path$$1) {
      var node = path$$1.node;

      var parts = flatten(node);

      if (parts) {
        meta.concatenations.push({
          node: cleanNode(node),
          parts: parts.map(cleanNode)
        });

        path$$1.replaceWith(combine(module, node, parts));
      }
    }
  };
}

function flatten(node) {
  if (!isBinaryExpression(node) || node.operator !== '+') {
    return null;
  }

  if (node.loc.start.line !== node.loc.end.line) {
    return null;
  }

  var left = node.left,
      right = node.right;

  // A string ending with \0 could make an octal literal if combined with
  // the next string, so just ignore it.

  if (isStringLiteral(left) && left.value.endsWith('\0') || isStringLiteral(right) && right.value.endsWith('\0')) {
    return null;
  }

  if (isStringLiteral(left)) {
    // This is the root.
    return [left, right];
  } else {
    // We need to go deeper.
    var flattenedLeft = flatten(left);

    if (!flattenedLeft) {
      return null;
    }

    return [].concat(toConsumableArray(flattenedLeft), [right]);
  }
}

function combine(module, node, parts) {
  var annotatedParts = parts.map(function (part, i) {
    var previousPart = parts[i - 1];
    var nextPart = parts[i + 1];
    var annotatedPart = {
      node: part,
      prefix: '',
      suffix: ''
    };

    if (previousPart) {
      var _insignificantContent = insignificantContentSeparatedByPlus(module, previousPart, part),
          _insignificantContent2 = slicedToArray(_insignificantContent, 2),
          prefix = _insignificantContent2[1];

      annotatedPart.prefix = prefix.replace(/^\s*/, '');
    }

    if (nextPart) {
      var _insignificantContent3 = insignificantContentSeparatedByPlus(module, part, nextPart),
          _insignificantContent4 = slicedToArray(_insignificantContent3, 1),
          suffix = _insignificantContent4[0];

      annotatedPart.suffix = suffix.replace(/\s*$/, '');
    }

    return annotatedPart;
  });

  if (annotatedParts.every(function (part) {
    return isStringLiteral(part.node) && !part.prefix && !part.suffix;
  })) {
    return combineStrings(module, parts);
  } else {
    return buildTemplateString(module, node, annotatedParts);
  }
}

function combineStrings(module, parts) {
  var quote = module.source.charAt(parts[0].start);
  var value = parts[0].value;


  for (var i = 0; i < parts.length; i++) {
    var thisPart = parts[i];
    var nextPart = parts[i + 1];
    if (nextPart) {
      // Remove the space between the strings.
      module.magicString.remove(thisPart.end - 1, nextPart.start + 1);
      value += nextPart.value;
    }
    var thisPartQuote = module.source.charAt(parts[i].start);
    var originalString = module.magicString.slice(thisPart.start + 1, thisPart.end - 1);
    var convertedString = convertStringEscaping(thisPartQuote, quote, originalString);
    if (originalString !== convertedString) {
      module.magicString.overwrite(thisPart.start + 1, thisPart.end - 1, convertedString);
    }
  }

  var lastPart = parts[parts.length - 1];
  module.magicString.overwrite(lastPart.end - 1, lastPart.end, quote);

  return stringLiteral(value);
}

function buildTemplateString(module, node, parts) {
  var expressions = [];
  var quasis = [];

  var firstPart = parts[0];
  var firstNode = firstPart.node;
  var cooked = '';
  var raw = '';

  module.magicString.appendLeft(firstNode.start, '`');

  parts.forEach(function (_ref, i) {
    var node = _ref.node,
        prefix = _ref.prefix,
        suffix = _ref.suffix;

    if (prefix || suffix || !isStringLiteral(node)) {
      // This one has to be an interpolated expression.
      module.magicString.appendRight(node.start, '${' + prefix);
      module.magicString.appendLeft(node.end, suffix + '}');
      expressions.push(node);
      quasis.push(templateElement({ cooked: cooked, raw: raw }, false));
      cooked = '';
      raw = '';
    } else {
      // This one can become a quasi,
      cooked += node.value;
      raw += convertStringEscaping(node.extra.raw[0], '`', node.extra.raw.slice(1, -1));
      module.magicString.remove(node.start, node.start + 1);
      module.magicString.remove(node.end - 1, node.end);
      var thisPartQuote = module.source.charAt(node.start);
      var originalString = module.magicString.slice(node.start + 1, node.end - 1);
      var convertedString = convertStringEscaping(thisPartQuote, '`', originalString);
      if (originalString !== convertedString) {
        module.magicString.overwrite(node.start + 1, node.end - 1, convertedString);
      }
    }

    var nextPart = parts[i + 1];

    if (nextPart) {
      module.magicString.remove(node.end, nextPart.node.start);
    }
  });

  quasis.push(templateElement({ cooked: cooked, raw: raw }, true));

  var lastPart = parts[parts.length - 1];

  if (lastPart.node.end === node.end) {
    module.magicString.appendRight(node.end, '`');
  } else {
    module.magicString.overwrite(lastPart.node.end, node.end, '`');
  }

  return templateLiteral(quasis, expressions);
}

function insignificantContentSeparatedByPlus(module, left, right) {
  var tokens = module.tokensInRange(left.end, right.start);
  var leftComments = [];
  var rightComments = [];
  var hasFoundPlusToken = false;
  var last = left;

  tokens.forEach(function (token, i) {
    var next = tokens[i + 1] || right;
    if (token.type.label === '+/-' && token.value === '+') {
      hasFoundPlusToken = true;
    } else if (token.type === 'CommentBlock') {
      var expandedSource = module.source.slice(last.end, next.start);
      (hasFoundPlusToken ? rightComments : leftComments).push(expandedSource);
    }
    last = token;
  });

  return [leftComments.join(''), rightComments.join('')];
}

function metadata$4(module) {
  if (!module.metadata[name$4]) {
    module.metadata[name$4] = { concatenations: [] };
  }
  return module.metadata[name$4];
}



var stringsTemplate = Object.freeze({
	name: name$4,
	description: description$4,
	visitor: visitor$4
});

var name$5 = 'objects.shorthand';
var description$5 = 'Use shorthand notation for object properties.';

function visitor$5(module) {
  var meta = metadata$5(module);

  return {
    ObjectProperty: function ObjectProperty(path$$1) {
      var node = path$$1.node;


      if (node.computed || node.shorthand) {
        return;
      }

      if (!isIdentifier(node.key) || !isIdentifier(node.value)) {
        return;
      }

      if (node.key.name !== node.value.name) {
        return;
      }

      var tokens = module.tokensForNode(node);

      var _findTokenMatchingPre = findTokenMatchingPredicate(function (token) {
        return token.start === node.key.start;
      }, tokens),
          keyTokenIndex = _findTokenMatchingPre.index,
          keyToken = _findTokenMatchingPre.token;

      var _findTokenMatchingPre2 = findTokenMatchingPredicate(function (token) {
        return token.type.label === ':';
      }, tokens, keyTokenIndex),
          colonTokenIndex = _findTokenMatchingPre2.index,
          colonToken = _findTokenMatchingPre2.token;

      var _findTokenMatchingPre3 = findTokenMatchingPredicate(function (token) {
        return token.start === node.value.start;
      }, tokens, colonTokenIndex),
          valueToken = _findTokenMatchingPre3.token;

      var sourceBetweenKeyAndColon = module.source.slice(keyToken.end, colonToken.start);
      var sourceBetweenColonAndValue = module.source.slice(colonToken.end, valueToken.start);

      // `a /* 1 */ : /* 2 */ a` -> `/* 1 *//* 2 */a`
      //  ^^^^^^^^^^^                ^^^^^^^
      module.magicString.overwrite(keyToken.start, colonToken.end, sourceBetweenKeyAndColon.trim());

      // `a /* 1 */ : /* 2 */ a` -> `/* 1 *//* 2 */a`
      //             ^^^^^^^^^              ^^^^^^^
      if (colonToken.end !== valueToken.start) {
        module.magicString.overwrite(colonToken.end, valueToken.start, sourceBetweenColonAndValue.trim());
      }

      meta.properties.push(cleanNode(node));
      node.shorthand = true;
    }
  };
}

function metadata$5(module) {
  if (!module.metadata[name$5]) {
    module.metadata[name$5] = { properties: [] };
  }
  return module.metadata[name$5];
}

var objectsShorthand = Object.freeze({
	name: name$5,
	description: description$5,
	visitor: visitor$5
});

var name$6 = 'objects.concise';
var description$6 = 'Use concise object property method syntax.';

function visitor$6(module) {
  return {
    ObjectProperty: function ObjectProperty(path$$1) {
      var node = path$$1.node;


      if (node.method) {
        return;
      }

      if (!isFunctionExpression(node.value) || node.value.id) {
        return;
      }

      var tokens = module.tokensForNode(node);
      var keyEnd = node.key.end;
      var functionEnd = void 0;

      if (node.computed) {
        var _findToken = findToken('[', tokens, 0),
            startBracketIndex = _findToken.index;

        var _findEndTokenBalanced = findEndTokenBalanced('[', ']', tokens, startBracketIndex),
            endBracketIndex = _findEndTokenBalanced.index,
            endBracket = _findEndTokenBalanced.token;

        keyEnd = endBracket.end;
        functionEnd = findToken('function', tokens, endBracketIndex).token.end;
      } else {
        functionEnd = findToken('function', tokens, 0).token.end;
      }

      module.magicString.remove(keyEnd, functionEnd);
      metadata$6(module).properties.push(cleanNode(node));

      path$$1.replaceWith(objectMethod('method', node.key, node.value.params, node.value.body, node.computed));
    }
  };
}

function metadata$6(module) {
  if (!module.metadata[name$6]) {
    module.metadata[name$6] = {
      properties: []
    };
  }
  return module.metadata[name$6];
}

var objectsConcise = Object.freeze({
	name: name$6,
	description: description$6,
	visitor: visitor$6
});

var allPlugins = [objectsShorthand, objectsConcise, modulesCommonjs, functionsArrow, declarationsBlockScope, objectsDestructuring, stringsTemplate];

/* eslint-disable no-console */

var OptionError = function (_Error) {
  inherits(OptionError, _Error);

  function OptionError(message) {
    classCallCheck(this, OptionError);

    var _this = possibleConstructorReturn(this, (OptionError.__proto__ || Object.getPrototypeOf(OptionError)).call(this, message));

    _this.message = message;
    return _this;
  }

  return OptionError;
}(Error);

var DelayedWritableFileStream = function () {
  function DelayedWritableFileStream(path$$1, options) {
    classCallCheck(this, DelayedWritableFileStream);

    this.path = path$$1;
    this.options = options;
  }

  createClass(DelayedWritableFileStream, [{
    key: 'write',
    value: function write(chunk) {
      return this.stream.write(chunk);
    }
  }, {
    key: 'end',
    value: function end() {
      return this.stream.end();
    }
  }, {
    key: 'stream',
    get: function get$$1() {
      if (!this._stream) {
        mkdirp.sync(dirname(this.path));
        this._stream = createWriteStream(this.path, this.options);
      }
      return this._stream;
    }
  }]);
  return DelayedWritableFileStream;
}();

function run$$1(args) {
  var options = parseArguments(args);

  if (options.error) {
    process.stderr.write(options.error + '\n');
    help(process.stderr);
    process.exit(1);
  } else if (options.help) {
    help(process.stdout);
  } else {
    var _input = options.input ? createReadStream(options.input, { encoding: 'utf8' }) : process.stdin;
    var _output = options.output ? new DelayedWritableFileStream(options.output, { encoding: 'utf8' }) : process.stdout;

    var plugins = allPlugins.filter(function (plugin) {
      if (options.blacklist) {
        return options.blacklist[plugin.name] !== true;
      } else if (options.whitelist) {
        return options.whitelist[plugin.name] === true;
      } else {
        return true;
      }
    });

    readStream(_input).then(function (source) {
      return convert(source, { plugins: plugins, validate: options.validate, parse: options.parse });
    }).then(function (result) {
      printWarnings(_input.path || '[stdin]', result.warnings);
      _output.write(result.code);
    }).catch(function (error) {
      console.error(error.stack);
      process.exit(1);
    });
  }
}

function printWarnings(path$$1, warnings) {
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = warnings[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var warning = _step.value;

      printWarning(path$$1, warning);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}

function printWarning(path$$1, warning) {
  var loc = warning.node.loc;
  process.stderr.write('WARNING: ' + path$$1 + ':' + loc.start.line + ':' + (loc.start.column + 1) + '  ' + warning.type + '  ' + warning.message + '\n');
}

function readStream(stream) {
  return new Promise(function (resolve, reject) {
    var data = '';
    stream.setEncoding('utf8');
    stream.on('data', function (chunk) {
      return data += chunk;
    });
    stream.on('error', reject);
    stream.on('end', function () {
      return resolve(data);
    });
  });
}

function parseArguments(args) {
  var blacklist = null;
  var whitelist = null;
  var input = void 0;
  var output = void 0;
  var validate = void 0;
  var inline = false;
  var parse$$1 = void 0;

  for (var i = 0; i < args.length; i++) {
    switch (args[i]) {
      case '-i':
      case '--input':
        if (input) {
          return { error: 'Encountered duplicate input option: ' + args[i + 1] };
        }
        input = parsePath(args[++i]);
        break;

      case '-o':
      case '--output':
        if (output) {
          return { error: 'Encountered duplicate output option: ' + args[i + 1] };
        }
        output = parsePath(args[++i]);
        break;

      case '-h':
      case '--help':
        return { help: true };

      case '-w':
      case '--whitelist':
        if (blacklist) {
          return { error: 'Encountered whitelist after blacklist: ' + args[i + 1] };
        }
        if (!whitelist) {
          whitelist = blank();
        }
        parseList(args[++i]).forEach(function (name) {
          return whitelist[name] = true;
        });
        break;

      case '-b':
      case '--blacklist':
        if (whitelist) {
          return { error: 'Encountered blacklist after whitelist: ' + args[i + 1] };
        }
        if (!blacklist) {
          blacklist = blank();
        }
        parseList(args[++i]).forEach(function (name) {
          return blacklist[name] = true;
        });
        break;

      case '-I':
      case '--inline':
        inline = true;
        break;

      case '--validate':
      case '--no-validate':
        validate = args[i] === '--validate';
        break;

      default:
        if (args[i][0] === '-') {
          return { error: 'Unknown option: ' + args[i] };
        }
        if (input) {
          return { error: 'Duplicate input option: ' + args[i] };
        }
        input = args[i];
        break;
    }
  }

  if (inline) {
    if (!input) {
      return { error: 'Asked to replace input inline but no input was given' };
    } else if (output) {
      return { error: 'Asked to replace input inline but output is already set: ' + output };
    }
    output = input;
  }

  return { input: input, output: output, blacklist: blacklist, whitelist: whitelist, validate: validate, parse: parse$$1 };
}

function parseList(arg) {
  if (arg === '') {
    return [];
  } else if (!arg || arg[0] === '-') {
    throw new OptionError('Expected a list but got: ' + arg);
  }
  return arg.split(',').filter(function (item) {
    return item;
  });
}

function parsePath(arg) {
  if (!arg || arg[0] === '-') {
    throw new OptionError('Expected a path but got: ' + arg);
  }
  return arg;
}

function help(out) {
  var $0 = basename(process.argv[1]);
  out.write($0 + ' -o output.js input.js   # read and write files directly\n');
  out.write($0 + ' input.js > output.js    # read file and write stdout\n');
  out.write($0 + ' < input.js > output.js  # read stdin and write stdout\n');
  out.write($0 + ' -I file.js              # rewrite a file inline\n');
  out.write($0 + ' -b modules.commonjs     # blacklist plugins\n');
  out.write($0 + ' -w modules.commonjs     # whitelist plugins\n');
  out.write('\n');
  writeSectionHeader(out, 'Built-in Plugins');
  out.write('\n');
  table({ out: out, padding: 2, indent: 2 }, allPlugins.sort(function (left, right) {
    return left.name.localeCompare(right.name);
  }).map(function (_ref) {
    var name = _ref.name,
        description = _ref.description;
    return [name, description];
  }));
  out.write('\n');
  writeSectionHeader(out, 'Additional Options');
  out.write('\n');
  table({ out: out, padding: 4, indent: 2 }, [['--[no-]validate', 'Turn validation on or off (default: on).']]);
}

function writeSectionHeader(out, title) {
  if (out.isTTY) {
    out.write('\x1b[1m');
  }
  out.write(title + '\n');
  if (out.isTTY) {
    out.write('\x1b[0m');
  }
}

function table(options, data) {
  var padding = options.padding || 0;
  var indent = options.indent || 0;
  var out = options.out;
  var longest = [];

  data.forEach(function (row) {
    row.forEach(function (value, i) {
      if (!(i in longest) || value.length > longest[i]) {
        longest[i] = value.length;
      }
    });
  });

  data.forEach(function (row) {
    for (var j = indent; j--;) {
      out.write(' ');
    }
    row.forEach(function (value, i) {
      out.write(value);
      for (var _j = longest[i] + padding - value.length; _j--;) {
        out.write(' ');
      }
    });
    out.write('\n');
  });
}

function blank() {
  return Object.create(null);
}

function convert(source) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (Array.isArray(options)) {
    console.warn('convert(source, plugins) is deprecated, please call as convert(source, options)'); // eslint-disable-line no-console
    options = { plugins: options };
  }

  var _options = options,
      _options$validate = _options.validate,
      validate = _options$validate === undefined ? true : _options$validate,
      _options$plugins = _options.plugins,
      plugins = _options$plugins === undefined ? allPlugins : _options$plugins;

  var shebangMatch = source.match(shebangRegex);

  if (shebangMatch) {
    source = source.slice(shebangMatch.index + shebangMatch[0].length);
  }

  var module = new Module(null, source, parse$1(source));

  plugins.forEach(function (plugin) {
    var name = plugin.name,
        visitor = plugin.visitor;

    var pluginOptions = options[name];
    try {
      traverse(module.ast, visitor(module, pluginOptions));
      module.commit();
    } catch (e) {
      e.message = 'Error running plugin ' + name + ': ' + e.message;
      e.source = module.source;
      throw e;
    }
  });

  var result = module.render();

  if (validate) {
    var error = validateResult(result);
    if (error) {
      result.warnings.push({
        type: 'output-validation-failure',
        message: error.message,
        node: {
          loc: {
            start: error.loc
          }
        }
      });
    }
  }

  if (shebangMatch) {
    result.code = shebangMatch[0] + result.code;
  }

  return result;
}

function validateResult(_ref) {
  var code = _ref.code;

  try {
    parse$1(code);
    return null;
  } catch (ex) {
    return ex;
  }
}

export { allPlugins, convert, run$$1 as run };
