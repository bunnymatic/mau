import * as tslib_1 from "tslib";
import determineIndent from '../utils/determineIndent';
import NodePatcher from './NodePatcher';
var ProgramPatcher = (function (_super) {
    tslib_1.__extends(ProgramPatcher, _super);
    function ProgramPatcher(patcherContext, body) {
        var _this = _super.call(this, patcherContext) || this;
        _this.helpers = new Map();
        _this._indentString = null;
        _this.body = body;
        return _this;
    }
    ProgramPatcher.prototype.shouldTrimContentRange = function () {
        return true;
    };
    /**
     * Register a helper to be reused in several places.
     *
     * FIXME: Pick a different name than what is in scope.
     */
    ProgramPatcher.prototype.registerHelper = function (name, code) {
        code = code.trim();
        if (this.helpers.has(name)) {
            if (this.helpers.get(name) !== code) {
                throw new Error("BUG: cannot override helper '" + name + "'");
            }
        }
        else {
            this.helpers.set(name, code);
        }
        return name;
    };
    ProgramPatcher.prototype.patchHelpers = function () {
        try {
            for (var _a = tslib_1.__values(this.helpers.values()), _b = _a.next(); !_b.done; _b = _a.next()) {
                var helper = _b.value;
                this.editor.append("\n" + helper);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var e_1, _c;
    };
    /**
     * Gets the indent string used for each indent in this program.
     */
    ProgramPatcher.prototype.getProgramIndentString = function () {
        if (!this._indentString) {
            this._indentString = determineIndent(this.context.source);
        }
        return this._indentString;
    };
    return ProgramPatcher;
}(NodePatcher));
export default ProgramPatcher;
