import * as tslib_1 from "tslib";
import { SourceType } from 'coffee-lex';
import getStartOfLine from '../../../utils/getStartOfLine';
import SharedBlockPatcher from './../../../patchers/SharedBlockPatcher';
var BlockPatcher = (function (_super) {
    tslib_1.__extends(BlockPatcher, _super);
    function BlockPatcher() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    BlockPatcher.prototype.patchAsExpression = function () {
        this.patchAsStatement();
    };
    BlockPatcher.prototype.patchAsStatement = function () {
        if (this.node.inline) {
            try {
                for (var _a = tslib_1.__values(this.statements.entries()), _b = _a.next(); !_b.done; _b = _a.next()) {
                    var _c = tslib_1.__read(_b.value, 2), i = _c[0], statement = _c[1];
                    statement.patch();
                    if (i < this.statements.length - 1) {
                        this.normalizeBetweenStatements(statement, this.statements[i + 1]);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_b && !_b.done && (_d = _a.return)) _d.call(_a);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return;
        }
        // Having inconsistent indentation within a block is allowed in some cases
        // when there are implicit function calls, but when function call parens are
        // added, the inconsistent indentation can make the CoffeeScript invalid. So
        // we need to correct any inconsistent indentation in the normalize step so
        // that the result CoffeeScript will always be valid.
        var blockIndentLength = null;
        try {
            for (var _e = tslib_1.__values(this.statements.entries()), _f = _e.next(); !_f.done; _f = _e.next()) {
                var _g = tslib_1.__read(_f.value, 2), i = _g[0], statement = _g[1];
                var indentLength = this.getIndentLength(statement);
                if (indentLength !== null) {
                    if (blockIndentLength === null) {
                        blockIndentLength = indentLength;
                    }
                    else {
                        var charsToRemove = indentLength - blockIndentLength;
                        if (charsToRemove < 0) {
                            throw this.error('Unexpected statement at an earlier indentation level than an ' +
                                'earlier statement in the block.');
                        }
                        if (charsToRemove > 0) {
                            this.removePrecedingSpaceChars(statement.outerStart, charsToRemove);
                        }
                    }
                }
                statement.patch();
                if (i < this.statements.length - 1) {
                    this.normalizeBetweenStatements(statement, this.statements[i + 1]);
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_h = _e.return)) _h.call(_e);
            }
            finally { if (e_2) throw e_2.error; }
        }
        var e_1, _d, e_2, _h;
    };
    /**
     * Get rid of some number of spaces of indentation before this point in the
     * code. We need to be careful to only remove ranges that have not had any
     * inserts yet, since otherwise we might remove other code in addition to the
     * whitespace, or we might remove too much whitespace.
     */
    BlockPatcher.prototype.removePrecedingSpaceChars = function (index, numToRemove) {
        var numRemaining = numToRemove;
        for (var i = index; numRemaining > 0 && i > 0; i--) {
            var contents = this.slice(i - 1, i);
            if (contents.includes('\n')) {
                throw this.error('Found start of line before removing enough indentation.');
            }
            if (contents === ' ' || contents === '\t') {
                this.remove(i - 1, i);
                numRemaining -= 1;
            }
        }
    };
    /**
     * If this statement starts immediately after its line's initial indentation,
     * return the length of that indentation. Otherwise, return null.
     */
    BlockPatcher.prototype.getIndentLength = function (statement) {
        var startOfLine = getStartOfLine(this.context.source, statement.outerStart);
        var indentText = this.context.source.slice(startOfLine, statement.outerStart);
        if (/^[ \t]*$/.test(indentText)) {
            return indentText.length;
        }
        else {
            return null;
        }
    };
    /**
     * Statements can be comma-separated within classes, which is equivalent to
     * semicolons, so just change them to semicolons.
     */
    BlockPatcher.prototype.normalizeBetweenStatements = function (leftStatement, rightStatement) {
        var commaTokenIndex = this.indexOfSourceTokenBetweenPatchersMatching(leftStatement, rightStatement, function (t) { return t.type === SourceType.COMMA; });
        if (!commaTokenIndex) {
            return;
        }
        var commaToken = this.sourceTokenAtIndex(commaTokenIndex);
        if (!commaToken) {
            return;
        }
        this.overwrite(commaToken.start, commaToken.end, ';');
    };
    return BlockPatcher;
}(SharedBlockPatcher));
export default BlockPatcher;
