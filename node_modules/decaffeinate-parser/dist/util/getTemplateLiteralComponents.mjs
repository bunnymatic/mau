import SourceType from 'coffee-lex/dist/SourceType';
import { Literal, Op, Value } from 'decaffeinate-coffeescript/lib/coffee-script/nodes';
import { Quasi } from '../nodes';
import isImplicitPlusOp from './isImplicitPlusOp';
import parseString from './parseString';
/**
 * Reconstruct template literal information given the coffee-lex tokens and the
 * CoffeeScript AST. Since the CoffeeScript AST doesn't attempt to represent a
 * template literal (it's a bunch of + operations instead), the source locations
 * are generally unreliable and we need to rely on the token locations instead.
 */
export default function getTemplateLiteralComponents(context, node) {
    var tokens = context.sourceTokens;
    var quasis = [];
    var unmappedExpressions = [];
    var elements = getElements(node, context);
    var nodeRange = context.getRange(node);
    if (!nodeRange) {
        throw new Error('Expected valid range on template literal node.');
    }
    var _a = getStartToken(nodeRange[0], tokens), startTokenIndex = _a.startTokenIndex, startToken = _a.startToken;
    var depth = 0;
    var lastToken = startToken;
    for (var tokenIndex = startTokenIndex; tokenIndex; tokenIndex = tokenIndex.next()) {
        var token = tokens.tokenAtIndex(tokenIndex);
        if (!token) {
            break;
        }
        if (token.type === SourceType.INTERPOLATION_START) {
            depth++;
            if (depth === 1) {
                quasis.push(findQuasi(lastToken, token, context, elements));
                lastToken = token;
            }
        }
        else if (token.type === SourceType.INTERPOLATION_END) {
            depth--;
            if (depth === 0) {
                unmappedExpressions.push(findExpression(lastToken, token, context, elements));
                lastToken = token;
            }
        }
        else if (depth === 0 && isTemplateLiteralEnd(token)) {
            quasis.push(findQuasi(lastToken, token, context, elements));
            lastToken = token;
            break;
        }
    }
    return {
        quasis: quasis,
        unmappedExpressions: unmappedExpressions,
        start: startToken.start,
        end: lastToken.end
    };
}
function getElements(node, context) {
    if (node instanceof Op && isImplicitPlusOp(node, context)) {
        if (!node.second) {
            throw new Error('Expected second operand on plus op.');
        }
        return getElements(node.first, context).concat(getElements(node.second, context));
    }
    return [node];
}
/**
 * Usually the start token is at the start index of the relevant AST node, but
 * if the start of the template literal is an interpolation, it's two before
 * that one, so check to see which case we are and return what we find.
 */
function getStartToken(start, tokens) {
    var tokenIndex = tokens.indexOfTokenNearSourceIndex(start);
    for (var i = 0; i < 5; i++) {
        var token = tokens.tokenAtIndex(tokenIndex);
        if (!token) {
            throw new Error('Expected to find a start token in a template literal.');
        }
        if (isTemplateLiteralStart(token)) {
            return { startToken: token, startTokenIndex: tokenIndex };
        }
        var prevToken = tokenIndex.previous();
        if (!prevToken) {
            throw new Error('Expected a previous token when searching for a template start.');
        }
        tokenIndex = prevToken;
    }
    throw new Error('Expected a template literal start token.');
}
function findQuasi(leftToken, rightToken, context, elements) {
    var matchingElements = elements.filter(function (elem) {
        var range = context.getRange(elem);
        if (!range) {
            throw new Error('Unexpected invalid range.');
        }
        return range[0] >= leftToken.start && range[1] <= rightToken.end;
    });
    var start = leftToken.end;
    var end = rightToken.start;
    var startLoc = context.linesAndColumns.locationForIndex(leftToken.end);
    if (!startLoc) {
        throw new Error("Expected to find a location for index " + leftToken.end + ".");
    }
    var raw = context.source.slice(start, end);
    if (matchingElements.length === 0) {
        return new Quasi(startLoc.line + 1, startLoc.column + 1, start, end, raw, '');
    }
    else if (matchingElements.length === 1) {
        var element = matchingElements[0];
        var literal = void 0;
        if (element instanceof Literal) {
            literal = element;
        }
        else if (element instanceof Value && element.properties.length === 0 && element.base instanceof Literal) {
            literal = element.base;
        }
        else {
            throw new Error('Expected quasi element to be either a literal or a value containing only a literal.');
        }
        var stringValue = parseString(literal.value);
        return new Quasi(startLoc.line + 1, startLoc.column + 1, start, end, raw, stringValue !== undefined ? stringValue : literal.value);
    }
    else {
        throw new Error('Unexpectedly found multiple elements in string interpolation.');
    }
}
function findExpression(leftToken, rightToken, context, elements) {
    var matchingElements = elements.filter(function (elem) {
        var range = context.getRange(elem);
        if (!range) {
            throw new Error('Unexpected invalid range.');
        }
        return range[0] >= leftToken.start && range[1] <= rightToken.end;
    });
    if (matchingElements.length === 0) {
        return null;
    }
    else if (matchingElements.length === 1) {
        return matchingElements[0];
    }
    else {
        throw new Error('Unexpectedly found multiple elements in string interpolation.');
    }
}
function isTemplateLiteralStart(token) {
    return [
        SourceType.DSTRING_START,
        SourceType.SSTRING_START,
        SourceType.TDSTRING_START,
        SourceType.TSSTRING_START,
        SourceType.HEREGEXP_START,
    ].indexOf(token.type) >= 0;
}
function isTemplateLiteralEnd(token) {
    return [
        SourceType.DSTRING_END,
        SourceType.SSTRING_END,
        SourceType.TDSTRING_END,
        SourceType.TSSTRING_END,
        SourceType.HEREGEXP_END,
    ].indexOf(token.type) >= 0;
}
