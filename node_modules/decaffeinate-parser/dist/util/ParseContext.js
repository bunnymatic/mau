"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var nodes_1 = require("decaffeinate-coffeescript/lib/coffee-script/nodes");
var lines_and_columns_1 = require("lines-and-columns");
var ParseError = (function (_super) {
    __extends(ParseError, _super);
    function ParseError(syntaxError) {
        var _this = _super.call(this, syntaxError.message) || this;
        _this.syntaxError = syntaxError;
        return _this;
    }
    return ParseError;
}(Error));
/**
 * Any information we need to know about the current state of parsing. While the
 * hope is that this is mostly immutable, with replace operations as we walk the
 * AST, it is partially mutable to collect bound method names in a class.
 */
var ParseState = (function () {
    function ParseState(currentClassBoundMethods) {
        this.currentClassBoundMethods = currentClassBoundMethods;
        this.currentClassCtor = null;
    }
    ParseState.prototype.isInClassBody = function () {
        return this.currentClassBoundMethods !== null;
    };
    ParseState.prototype.recordBoundMethod = function (method) {
        if (!this.currentClassBoundMethods) {
            throw new Error('Cannot assign a bound method name when there is no current class.');
        }
        this.currentClassBoundMethods.push(method);
    };
    ParseState.prototype.recordConstructor = function (ctor) {
        this.currentClassCtor = ctor;
    };
    ParseState.prototype.pushCurrentClass = function () {
        return new ParseState([]);
    };
    ParseState.prototype.dropCurrentClass = function () {
        return new ParseState(null);
    };
    ParseState.initialState = function () {
        return new ParseState(null);
    };
    return ParseState;
}());
exports.ParseState = ParseState;
var ParseContext = (function () {
    function ParseContext(source, linesAndColumns, sourceTokens, ast, parseState) {
        this.source = source;
        this.linesAndColumns = linesAndColumns;
        this.sourceTokens = sourceTokens;
        this.ast = ast;
        this.parseState = parseState;
    }
    ParseContext.prototype.getRange = function (locatable) {
        if (locatable instanceof nodes_1.Base) {
            return this.getRange(locatable.locationData);
        }
        else {
            var locationData = locatable;
            var start = this.linesAndColumns.indexForLocation({ line: locationData.first_line, column: locationData.first_column });
            var end = this.linesAndColumns.indexForLocation({ line: locationData.last_line, column: locationData.last_column });
            if (start === null || end === null) {
                return null;
            }
            return [start, end + 1];
        }
    };
    ParseContext.fromSource = function (source, sourceLex, parse) {
        try {
            var sourceTokens = sourceLex(source);
            return new ParseContext(source, new lines_and_columns_1["default"](source), sourceTokens, parse(source), ParseState.initialState());
        }
        catch (ex) {
            if (ex instanceof SyntaxError) {
                throw new ParseError(ex);
            }
            else {
                throw ex;
            }
        }
    };
    ParseContext.prototype.updateState = function (updater) {
        return new ParseContext(this.source, this.linesAndColumns, this.sourceTokens, this.ast, updater(this.parseState));
    };
    return ParseContext;
}());
exports["default"] = ParseContext;
