"use strict";
exports.__esModule = true;
var coffee_lex_1 = require("coffee-lex");
var util_1 = require("util");
function getLocation(context, node) {
    var loc = node.locationData;
    var start = context.linesAndColumns.indexForLocation({ line: loc.first_line, column: loc.first_column });
    var last = context.linesAndColumns.indexForLocation({ line: loc.last_line, column: loc.last_column });
    if (start === null || last === null) {
        throw new Error("unable to determine range for location: " + util_1.inspect(loc) + "}");
    }
    var line = loc.first_line + 1;
    var column = loc.first_column + 1;
    var end = last + 1;
    // Shrink to be within the size of the source.
    if (start < 0) {
        start = 0;
    }
    if (end > context.source.length) {
        end = context.source.length;
    }
    var firstTokenOfNode = firstSemanticTokenAfter(context, start, node);
    var lastTokenOfNode = firstSemanticTokenBefore(context, end, node);
    start = firstTokenOfNode.start;
    end = lastTokenOfNode.end;
    var raw = context.source.slice(start, end);
    return { line: line, column: column, start: start, end: end, raw: raw };
}
exports["default"] = getLocation;
function firstSemanticTokenAfter(context, index, node) {
    var tokenIndex = context.sourceTokens.indexOfTokenMatchingPredicate(function (token) {
        return (token.start >= index &&
            token.type !== coffee_lex_1.SourceType.NEWLINE &&
            token.type !== coffee_lex_1.SourceType.COMMENT);
    }, context.sourceTokens.indexOfTokenNearSourceIndex(index));
    return tokenFromIndex(context, tokenIndex, node);
}
function firstSemanticTokenBefore(context, index, node) {
    var tokenIndex = context.sourceTokens.lastIndexOfTokenMatchingPredicate(function (token) {
        return (token.end <= index &&
            token.type !== coffee_lex_1.SourceType.NEWLINE &&
            token.type !== coffee_lex_1.SourceType.COMMENT);
    }, context.sourceTokens.indexOfTokenNearSourceIndex(index));
    return tokenFromIndex(context, tokenIndex, node);
}
function tokenFromIndex(context, tokenIndex, node) {
    if (tokenIndex === null) {
        throw new Error("unable to find token index for node: " + util_1.inspect(node));
    }
    var token = context.sourceTokens.tokenAtIndex(tokenIndex);
    if (token === null) {
        throw new Error("unable to find token for node: " + util_1.inspect(node));
    }
    return token;
}
