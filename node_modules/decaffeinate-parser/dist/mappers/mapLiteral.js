"use strict";
exports.__esModule = true;
var SourceType_1 = require("coffee-lex/dist/SourceType");
var util_1 = require("util");
var nodes_1 = require("../nodes");
var getLocation_1 = require("../util/getLocation");
var isStringAtPosition_1 = require("../util/isStringAtPosition");
var makeHeregex_1 = require("../util/makeHeregex");
var makeString_1 = require("../util/makeString");
var parseNumber_1 = require("../util/parseNumber");
var parseRegExp_1 = require("../util/parseRegExp");
var HEREGEX_PATTERN = /^\/\/\/((?:.|\s)*)\/\/\/([gimy]*)$/;
function mapLiteral(context, node) {
    var _a = getLocation_1["default"](context, node), line = _a.line, column = _a.column, start = _a.start, end = _a.end, raw = _a.raw;
    if (node.value === 'this') {
        return new nodes_1.This(line, column, start, end, raw);
    }
    var startTokenIndex = context.sourceTokens.indexOfTokenContainingSourceIndex(start);
    var lastTokenIndex = context.sourceTokens.indexOfTokenContainingSourceIndex(end - 1);
    if (!startTokenIndex || !lastTokenIndex) {
        throw new Error("cannot find start/end tokens for literal: " + util_1.inspect(node));
    }
    var startToken = context.sourceTokens.tokenAtIndex(startTokenIndex);
    var lastToken = context.sourceTokens.tokenAtIndex(lastTokenIndex);
    if (!startToken || !lastToken) {
        throw new Error("cannot find start/end tokens for literal: " + util_1.inspect(node));
    }
    if (startToken.type === SourceType_1["default"].IDENTIFIER) {
        // Sometimes the CoffeeScript AST contains a string object instead of a
        // string primitive. Convert to string primitive if necessary.
        var value = node.value.valueOf();
        return new nodes_1.Identifier(line, column, start, end, raw, value);
    }
    if (startToken.type === SourceType_1["default"].JS) {
        return new nodes_1.JavaScript(line, column, start, end, raw, node.value);
    }
    if (startToken.type === SourceType_1["default"].NUMBER) {
        if (raw.includes('.')) {
            return new nodes_1.Float(line, column, start, end, raw, parseNumber_1["default"](node.value));
        }
        else {
            return new nodes_1.Int(line, column, start, end, raw, parseNumber_1["default"](node.value));
        }
    }
    if (startToken.type === SourceType_1["default"].REGEXP) {
        var regExp = parseRegExp_1["default"](node.value);
        return new nodes_1.Regex(line, column, start, end, raw, regExp.pattern, nodes_1.RegexFlags.parse(regExp.flags || ''));
    }
    if (isStringAtPosition_1["default"](start, end, context)) {
        return makeString_1["default"](context, node);
    }
    if (startToken.type === SourceType_1["default"].HEREGEXP_START && lastToken.type === SourceType_1["default"].HEREGEXP_END) {
        var match = raw.match(HEREGEX_PATTERN);
        if (!match) {
            throw new Error("unable to parse flags of heregex: " + util_1.inspect(node));
        }
        var flags = match[2];
        return makeHeregex_1["default"](context, node, flags);
    }
    if (startToken.type === SourceType_1["default"].SSTRING_START ||
        startToken.type === SourceType_1["default"].DSTRING_START ||
        startToken.type === SourceType_1["default"].TSSTRING_START ||
        startToken.type === SourceType_1["default"].TDSTRING_START ||
        startToken.type === SourceType_1["default"].STRING_CONTENT ||
        startToken.type === SourceType_1["default"].STRING_PADDING ||
        startToken.type === SourceType_1["default"].STRING_LINE_SEPARATOR) {
        // In rare cases (a string with only an empty interpolation), a quasi can
        // live by itself in the CoffeeScript AST. In that case, turn it into a
        // string by analyzing the tokens.
        return makeString_1["default"](context, node);
    }
    if (startToken.type === SourceType_1["default"].BREAK) {
        return new nodes_1.Break(line, column, start, end, raw);
    }
    if (startToken.type === SourceType_1["default"].CONTINUE) {
        return new nodes_1.Continue(line, column, start, end, raw);
    }
    // Fall back to identifiers.
    return new nodes_1.Identifier(line, column, start, end, raw, node.value);
}
exports["default"] = mapLiteral;
