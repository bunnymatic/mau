import SourceToken from 'coffee-lex/dist/SourceToken';
import ParseContext from './util/ParseContext';
export declare abstract class Node {
    readonly type: string;
    readonly line: number;
    readonly column: number;
    readonly start: number;
    readonly end: number;
    readonly raw: string;
    parentNode: Node | null;
    constructor(type: string, line: number, column: number, start: number, end: number, raw: string);
    getChildren(): Array<Node>;
    getChildFields(): Array<Node | Array<Node | null> | null>;
    /**
     * Return the names of the properties container child nodes, in traversal
     * order.
     */
    abstract getChildNames(): Array<string>;
}
export declare class Identifier extends Node {
    readonly data: string;
    constructor(line: number, column: number, start: number, end: number, raw: string, data: string);
    getChildNames(): Array<keyof this>;
}
export declare class Bool extends Node {
    readonly data: boolean;
    constructor(line: number, column: number, start: number, end: number, raw: string, data: boolean);
    static true(): Bool;
    static false(): Bool;
    getChildNames(): Array<keyof this>;
}
export declare class JavaScript extends Node {
    readonly data: string;
    constructor(line: number, column: number, start: number, end: number, raw: string, data: string);
    getChildNames(): Array<keyof this>;
}
export declare class Number extends Node {
    readonly data: number;
    constructor(type: string, line: number, column: number, start: number, end: number, raw: string, data: number);
    getChildNames(): Array<keyof this>;
}
export declare class Float extends Number {
    constructor(line: number, column: number, start: number, end: number, raw: string, data: number);
}
export declare class Int extends Number {
    constructor(line: number, column: number, start: number, end: number, raw: string, data: number);
}
export declare abstract class AccessOp extends Node {
    readonly expression: Node;
    constructor(type: string, line: number, column: number, start: number, end: number, raw: string, expression: Node);
}
export declare class MemberAccessOp extends AccessOp {
    readonly member: Identifier;
    constructor(line: number, column: number, start: number, end: number, raw: string, expression: Node, member: Identifier);
    getChildNames(): Array<keyof this>;
}
export declare class ProtoMemberAccessOp extends AccessOp {
    constructor(line: number, column: number, start: number, end: number, raw: string, expression: Node);
    getChildNames(): Array<keyof this>;
}
export declare class SoakedMemberAccessOp extends AccessOp {
    readonly member: Identifier;
    constructor(line: number, column: number, start: number, end: number, raw: string, expression: Node, member: Identifier);
    getChildNames(): Array<keyof this>;
}
export declare class SoakedProtoMemberAccessOp extends AccessOp {
    constructor(line: number, column: number, start: number, end: number, raw: string, expression: Node);
    getChildNames(): Array<keyof this>;
}
export declare class DynamicMemberAccessOp extends AccessOp {
    readonly indexingExpr: Node;
    constructor(line: number, column: number, start: number, end: number, raw: string, expression: Node, indexingExpr: Node);
    getChildNames(): Array<keyof this>;
}
export declare class SoakedDynamicMemberAccessOp extends AccessOp {
    readonly indexingExpr: Node;
    constructor(line: number, column: number, start: number, end: number, raw: string, expression: Node, indexingExpr: Node);
    getChildNames(): Array<keyof this>;
}
export declare class Quasi extends Node {
    readonly data: string;
    constructor(line: number, column: number, start: number, end: number, raw: string, data: string);
    getChildNames(): Array<keyof this>;
}
export declare class String extends Node {
    readonly quasis: Array<Quasi>;
    readonly expressions: Array<Node | null>;
    constructor(line: number, column: number, start: number, end: number, raw: string, quasis: Array<Quasi>, expressions: Array<Node | null>);
    getChildNames(): Array<keyof this>;
}
export declare class ObjectInitialiser extends Node {
    readonly members: Array<ObjectInitialiserMember | AssignOp>;
    constructor(line: number, column: number, start: number, end: number, raw: string, members: Array<ObjectInitialiserMember | AssignOp>);
    getChildNames(): Array<keyof this>;
}
export declare class ObjectInitialiserMember extends Node {
    readonly key: Node;
    readonly expression: Node | null;
    constructor(line: number, column: number, start: number, end: number, raw: string, key: Node, expression: Node | null);
    getChildNames(): Array<keyof this>;
}
export declare class Conditional extends Node {
    readonly condition: Node;
    readonly consequent: Block | null;
    readonly alternate: Block | null;
    readonly isUnless: boolean;
    constructor(line: number, column: number, start: number, end: number, raw: string, condition: Node, consequent: Block | null, alternate: Block | null, isUnless: boolean);
    getChildNames(): Array<keyof this>;
}
export declare class Program extends Node {
    readonly body: Block | null;
    context: ParseContext;
    constructor(line: number, column: number, start: number, end: number, raw: string, body: Block | null, context: ParseContext);
    getChildNames(): Array<keyof this>;
}
export declare class Block extends Node {
    readonly statements: Array<Node>;
    readonly inline: boolean;
    constructor(line: number, column: number, start: number, end: number, raw: string, statements: Array<Node>, inline: boolean);
    getChildNames(): Array<keyof this>;
    withInline(inline: boolean): Block;
}
export declare class Loop extends Node {
    readonly body: Node | null;
    constructor(line: number, column: number, start: number, end: number, raw: string, body: Node | null);
    getChildNames(): Array<keyof this>;
}
export declare class While extends Node {
    readonly condition: Node;
    readonly guard: Node | null;
    readonly body: Node | null;
    readonly isUntil: boolean;
    constructor(line: number, column: number, start: number, end: number, raw: string, condition: Node, guard: Node | null, body: Node | null, isUntil: boolean);
    getChildNames(): Array<keyof this>;
}
export declare abstract class For extends Node {
    readonly keyAssignee: Node | null;
    readonly valAssignee: Node | null;
    readonly target: Node;
    readonly filter: Node | null;
    readonly body: Block | null;
    constructor(type: string, line: number, column: number, start: number, end: number, raw: string, keyAssignee: Node | null, valAssignee: Node | null, target: Node, filter: Node | null, body: Block | null);
}
export declare class ForOf extends For {
    readonly isOwn: boolean;
    constructor(line: number, column: number, start: number, end: number, raw: string, keyAssignee: Node | null, valAssignee: Node | null, target: Node, filter: Node | null, body: Block | null, isOwn: boolean);
    getChildNames(): Array<keyof this>;
}
export declare class ForIn extends For {
    readonly step: Node | null;
    constructor(line: number, column: number, start: number, end: number, raw: string, keyAssignee: Node | null, valAssignee: Node | null, target: Node, filter: Node | null, body: Block | null, step: Node | null);
    getChildNames(): Array<keyof this>;
}
export declare class Switch extends Node {
    readonly expression: Node | null;
    readonly cases: Array<SwitchCase>;
    readonly alternate: Block | null;
    constructor(line: number, column: number, start: number, end: number, raw: string, expression: Node | null, cases: Array<SwitchCase>, alternate: Block | null);
    getChildNames(): Array<keyof this>;
}
export declare class SwitchCase extends Node {
    readonly conditions: Array<Node>;
    readonly consequent: Block | null;
    constructor(line: number, column: number, start: number, end: number, raw: string, conditions: Array<Node>, consequent: Block | null);
    getChildNames(): Array<keyof this>;
}
export declare class RegexFlags {
    readonly global: boolean;
    readonly ignoreCase: boolean;
    readonly multiline: boolean;
    readonly sticky: boolean;
    readonly g: boolean;
    readonly i: boolean;
    readonly m: boolean;
    readonly y: boolean;
    constructor(global: boolean, ignoreCase: boolean, multiline: boolean, sticky: boolean);
    static parse(flags: string): RegexFlags;
}
export declare class Heregex extends Node {
    readonly quasis: Array<Quasi>;
    readonly expressions: Array<Node | null>;
    readonly flags: RegexFlags;
    constructor(line: number, column: number, start: number, end: number, raw: string, quasis: Array<Quasi>, expressions: Array<Node | null>, flags: RegexFlags);
    getChildNames(): Array<keyof this>;
}
export declare class Null extends Node {
    constructor(line: number, column: number, start: number, end: number, raw: string);
    getChildNames(): Array<keyof this>;
}
export declare class Undefined extends Node {
    constructor(line: number, column: number, start: number, end: number, raw: string);
    getChildNames(): Array<keyof this>;
}
export declare class Regex extends Node {
    readonly pattern: string;
    readonly flags: RegexFlags;
    constructor(line: number, column: number, start: number, end: number, raw: string, pattern: string, flags: RegexFlags);
    getChildNames(): Array<keyof this>;
}
export declare class Return extends Node {
    readonly expression: Node | null;
    constructor(line: number, column: number, start: number, end: number, raw: string, expression: Node | null);
    getChildNames(): Array<keyof this>;
}
export declare class YieldReturn extends Node {
    readonly expression: Node | null;
    constructor(line: number, column: number, start: number, end: number, raw: string, expression: Node | null);
    getChildNames(): Array<keyof this>;
}
export declare class This extends Node {
    constructor(line: number, column: number, start: number, end: number, raw: string);
    getChildNames(): Array<keyof this>;
}
export declare class Throw extends Node {
    readonly expression: Node | null;
    constructor(line: number, column: number, start: number, end: number, raw: string, expression: Node | null);
    getChildNames(): Array<keyof this>;
}
export declare class ArrayInitialiser extends Node {
    readonly members: Array<Node>;
    constructor(line: number, column: number, start: number, end: number, raw: string, members: Array<Node>);
    getChildNames(): Array<keyof this>;
}
export declare class DefaultParam extends Node {
    readonly param: Node;
    readonly default: Node;
    constructor(line: number, column: number, start: number, end: number, raw: string, param: Node, defaultValue: Node);
    getChildNames(): Array<keyof this>;
}
export declare class Rest extends Node {
    readonly expression: Node;
    constructor(line: number, column: number, start: number, end: number, raw: string, expression: Node);
    getChildNames(): Array<keyof this>;
}
export declare class Expansion extends Node {
    constructor(line: number, column: number, start: number, end: number, raw: string);
    getChildNames(): Array<keyof this>;
}
export declare class Break extends Node {
    constructor(line: number, column: number, start: number, end: number, raw: string);
    getChildNames(): Array<keyof this>;
}
export declare class Continue extends Node {
    constructor(line: number, column: number, start: number, end: number, raw: string);
    getChildNames(): Array<keyof this>;
}
export declare class Spread extends Node {
    readonly expression: Node;
    constructor(line: number, column: number, start: number, end: number, raw: string, expression: Node);
    getChildNames(): Array<keyof this>;
}
export declare class Range extends Node {
    readonly left: Node;
    readonly right: Node;
    readonly isInclusive: boolean;
    constructor(line: number, column: number, start: number, end: number, raw: string, left: Node, right: Node, isInclusive: boolean);
    getChildNames(): Array<keyof this>;
}
export declare abstract class BinaryOp extends Node {
    readonly left: Node;
    readonly right: Node;
    constructor(type: string, line: number, column: number, start: number, end: number, raw: string, left: Node, right: Node);
    getChildNames(): Array<string>;
}
export declare abstract class UnaryOp extends Node {
    readonly expression: Node;
    constructor(type: string, line: number, column: number, start: number, end: number, raw: string, expression: Node);
    getChildNames(): Array<keyof this>;
}
export declare class ChainedComparisonOp extends Node {
    readonly operands: Array<Node>;
    readonly operators: Array<OperatorInfo>;
    constructor(line: number, column: number, start: number, end: number, raw: string, operands: Array<Node>, operators: Array<OperatorInfo>);
    getChildNames(): Array<keyof this>;
}
export declare class OperatorInfo {
    readonly operator: string;
    readonly token: SourceToken;
    constructor(operator: string, token: SourceToken);
}
export declare type Op = UnaryOp | BinaryOp | ChainedComparisonOp;
export declare class EQOp extends BinaryOp {
    constructor(line: number, column: number, start: number, end: number, raw: string, left: Node, right: Node);
}
export declare class NEQOp extends BinaryOp {
    constructor(line: number, column: number, start: number, end: number, raw: string, left: Node, right: Node);
}
export declare class LTOp extends BinaryOp {
    constructor(line: number, column: number, start: number, end: number, raw: string, left: Node, right: Node);
}
export declare class LTEOp extends BinaryOp {
    constructor(line: number, column: number, start: number, end: number, raw: string, left: Node, right: Node);
}
export declare class GTOp extends BinaryOp {
    constructor(line: number, column: number, start: number, end: number, raw: string, left: Node, right: Node);
}
export declare class GTEOp extends BinaryOp {
    constructor(line: number, column: number, start: number, end: number, raw: string, left: Node, right: Node);
}
export declare class LogicalNotOp extends UnaryOp {
    constructor(line: number, column: number, start: number, end: number, raw: string, expression: Node);
}
export declare class LogicalAndOp extends BinaryOp {
    constructor(line: number, column: number, start: number, end: number, raw: string, left: Node, right: Node);
}
export declare class LogicalOrOp extends BinaryOp {
    constructor(line: number, column: number, start: number, end: number, raw: string, left: Node, right: Node);
}
export declare class SubtractOp extends BinaryOp {
    constructor(line: number, column: number, start: number, end: number, raw: string, left: Node, right: Node);
}
export declare class PlusOp extends BinaryOp {
    constructor(line: number, column: number, start: number, end: number, raw: string, left: Node, right: Node);
}
export declare class UnaryPlusOp extends UnaryOp {
    constructor(line: number, column: number, start: number, end: number, raw: string, expression: Node);
}
export declare class MultiplyOp extends BinaryOp {
    constructor(line: number, column: number, start: number, end: number, raw: string, left: Node, right: Node);
}
export declare class DivideOp extends BinaryOp {
    constructor(line: number, column: number, start: number, end: number, raw: string, left: Node, right: Node);
}
export declare class FloorDivideOp extends BinaryOp {
    constructor(line: number, column: number, start: number, end: number, raw: string, left: Node, right: Node);
}
export declare class ExistsOp extends BinaryOp {
    constructor(line: number, column: number, start: number, end: number, raw: string, left: Node, right: Node);
}
export declare class UnaryExistsOp extends UnaryOp {
    constructor(line: number, column: number, start: number, end: number, raw: string, expression: Node);
}
export declare class UnaryNegateOp extends UnaryOp {
    constructor(line: number, column: number, start: number, end: number, raw: string, expression: Node);
}
export declare class BitNotOp extends UnaryOp {
    constructor(line: number, column: number, start: number, end: number, raw: string, expression: Node);
}
export declare class BitAndOp extends BinaryOp {
    constructor(line: number, column: number, start: number, end: number, raw: string, left: Node, right: Node);
}
export declare class BitOrOp extends BinaryOp {
    constructor(line: number, column: number, start: number, end: number, raw: string, left: Node, right: Node);
}
export declare class BitXorOp extends BinaryOp {
    constructor(line: number, column: number, start: number, end: number, raw: string, left: Node, right: Node);
}
export declare class LeftShiftOp extends BinaryOp {
    constructor(line: number, column: number, start: number, end: number, raw: string, left: Node, right: Node);
}
export declare class SignedRightShiftOp extends BinaryOp {
    constructor(line: number, column: number, start: number, end: number, raw: string, left: Node, right: Node);
}
export declare class UnsignedRightShiftOp extends BinaryOp {
    constructor(line: number, column: number, start: number, end: number, raw: string, left: Node, right: Node);
}
export declare class PreDecrementOp extends UnaryOp {
    constructor(line: number, column: number, start: number, end: number, raw: string, expression: Node);
}
export declare class PreIncrementOp extends UnaryOp {
    constructor(line: number, column: number, start: number, end: number, raw: string, expression: Node);
}
export declare class PostDecrementOp extends UnaryOp {
    constructor(line: number, column: number, start: number, end: number, raw: string, expression: Node);
}
export declare class PostIncrementOp extends UnaryOp {
    constructor(line: number, column: number, start: number, end: number, raw: string, expression: Node);
}
export declare class ExpOp extends BinaryOp {
    constructor(line: number, column: number, start: number, end: number, raw: string, left: Node, right: Node);
}
export declare class RemOp extends BinaryOp {
    constructor(line: number, column: number, start: number, end: number, raw: string, left: Node, right: Node);
}
export declare class ModuloOp extends BinaryOp {
    constructor(line: number, column: number, start: number, end: number, raw: string, left: Node, right: Node);
}
export declare class InOp extends BinaryOp {
    readonly isNot: boolean;
    constructor(line: number, column: number, start: number, end: number, raw: string, left: Node, right: Node, isNot: boolean);
}
export declare class BaseAssignOp extends Node {
    readonly assignee: Node;
    readonly expression: Node;
    constructor(type: string, line: number, column: number, start: number, end: number, raw: string, assignee: Node, expression: Node);
    getChildNames(): Array<string>;
}
export declare class AssignOp extends BaseAssignOp {
    constructor(line: number, column: number, start: number, end: number, raw: string, assignee: Node, expression: Node);
    withExpression(expression: Node): AssignOp;
}
export declare class CompoundAssignOp extends BaseAssignOp {
    readonly op: string;
    constructor(line: number, column: number, start: number, end: number, raw: string, assignee: Node, expression: Node, op: string);
}
export declare class ExtendsOp extends BinaryOp {
    constructor(line: number, column: number, start: number, end: number, raw: string, left: Node, right: Node);
}
export declare class SeqOp extends BinaryOp {
    constructor(line: number, column: number, start: number, end: number, raw: string, left: Node, right: Node);
}
export declare class TypeofOp extends UnaryOp {
    constructor(line: number, column: number, start: number, end: number, raw: string, expression: Node);
}
export declare class InstanceofOp extends BinaryOp {
    readonly isNot: boolean;
    constructor(line: number, column: number, start: number, end: number, raw: string, left: Node, right: Node, isNot: boolean);
}
export declare class OfOp extends BinaryOp {
    readonly isNot: boolean;
    constructor(line: number, column: number, start: number, end: number, raw: string, left: Node, right: Node, isNot: boolean);
}
export declare class DeleteOp extends UnaryOp {
    constructor(line: number, column: number, start: number, end: number, raw: string, expression: Node);
}
export declare class Yield extends UnaryOp {
    constructor(line: number, column: number, start: number, end: number, raw: string, expression: Node);
}
export declare class YieldFrom extends UnaryOp {
    constructor(line: number, column: number, start: number, end: number, raw: string, expression: Node);
}
export declare class Slice extends Node {
    readonly expression: Node;
    readonly left: Node | null;
    readonly right: Node | null;
    readonly isInclusive: boolean;
    constructor(line: number, column: number, start: number, end: number, raw: string, expression: Node, left: Node | null, right: Node | null, isInclusive: boolean);
    getChildNames(): Array<keyof this>;
}
export declare class SoakedSlice extends Node {
    readonly expression: Node;
    readonly left: Node | null;
    readonly right: Node | null;
    readonly isInclusive: boolean;
    constructor(line: number, column: number, start: number, end: number, raw: string, expression: Node, left: Node | null, right: Node | null, isInclusive: boolean);
    getChildNames(): Array<keyof this>;
}
export declare abstract class BaseFunction extends Node {
    readonly parameters: Array<Node>;
    readonly body: Block | null;
    constructor(type: string, line: number, column: number, start: number, end: number, raw: string, parameters: Array<Node>, body: Block | null);
    getChildNames(): Array<keyof this>;
    abstract withParameters(parameters: Array<Node>): BaseFunction;
}
export declare class Function extends BaseFunction {
    constructor(line: number, column: number, start: number, end: number, raw: string, parameters: Array<Node>, body: Block | null);
    withParameters(parameters: Array<Node>): BaseFunction;
}
export declare class BoundFunction extends BaseFunction {
    constructor(line: number, column: number, start: number, end: number, raw: string, parameters: Array<Node>, body: Block | null);
    withParameters(parameters: Array<Node>): BaseFunction;
}
export declare class GeneratorFunction extends BaseFunction {
    constructor(line: number, column: number, start: number, end: number, raw: string, parameters: Array<Node>, body: Block | null);
    withParameters(parameters: Array<Node>): BaseFunction;
}
export declare class BoundGeneratorFunction extends BaseFunction {
    constructor(line: number, column: number, start: number, end: number, raw: string, parameters: Array<Node>, body: Block | null);
    withParameters(parameters: Array<Node>): BaseFunction;
}
export declare class Try extends Node {
    readonly body: Node | null;
    readonly catchAssignee: Node | null;
    readonly catchBody: Node | null;
    readonly finallyBody: Node | null;
    constructor(line: number, column: number, start: number, end: number, raw: string, body: Node | null, catchAssignee: Node | null, catchBody: Node | null, finallyBody: Node | null);
    getChildNames(): Array<keyof this>;
}
export declare class Constructor extends BaseAssignOp {
    constructor(line: number, column: number, start: number, end: number, raw: string, assignee: Node, expression: Node);
}
export declare class ClassProtoAssignOp extends BaseAssignOp {
    constructor(line: number, column: number, start: number, end: number, raw: string, assignee: Node, expression: Node);
}
export declare class Class extends Node {
    readonly nameAssignee: Node | null;
    readonly name: Node | null;
    readonly body: Block | null;
    readonly boundMembers: Array<ClassProtoAssignOp>;
    readonly parent: Node | null;
    readonly ctor: Constructor | null;
    constructor(line: number, column: number, start: number, end: number, raw: string, nameAssignee: Node | null, name: Node | null, body: Block | null, boundMembers: Array<ClassProtoAssignOp>, parent: Node | null, ctor: Constructor | null);
    getChildNames(): Array<keyof this>;
}
export declare class FunctionApplication extends Node {
    readonly function: Node;
    readonly arguments: Array<Node>;
    constructor(line: number, column: number, start: number, end: number, raw: string, fn: Node, args: Array<Node>);
    getChildNames(): Array<keyof this>;
}
export declare class SoakedFunctionApplication extends Node {
    readonly function: Node;
    readonly arguments: Array<Node>;
    constructor(line: number, column: number, start: number, end: number, raw: string, fn: Node, args: Array<Node>);
    getChildNames(): Array<keyof this>;
}
export declare class Super extends Node {
    constructor(line: number, column: number, start: number, end: number, raw: string);
    getChildNames(): Array<keyof this>;
}
export declare class BareSuperFunctionApplication extends Node {
    constructor(line: number, column: number, start: number, end: number, raw: string);
    getChildNames(): Array<keyof this>;
}
export declare class NewOp extends Node {
    readonly ctor: Node;
    readonly arguments: Array<Node>;
    constructor(line: number, column: number, start: number, end: number, raw: string, ctor: Node, args: Array<Node>);
    getChildNames(): Array<keyof this>;
}
export declare class SoakedNewOp extends Node {
    readonly ctor: Node;
    readonly arguments: Array<Node>;
    constructor(line: number, column: number, start: number, end: number, raw: string, ctor: Node, args: Array<Node>);
    getChildNames(): Array<keyof this>;
}
export declare class DoOp extends Node {
    readonly expression: Node;
    constructor(line: number, column: number, start: number, end: number, raw: string, expression: Node);
    getChildNames(): Array<keyof this>;
}
